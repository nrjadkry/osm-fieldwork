{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd17 Welcome to OSM Fieldwork Project \ud83e\udd17","text":""},{"location":"#history","title":"History \ud83d\udcd6","text":"<p>The History of the OSM Fieldwork Project begins with Rob Savoye, Senior Technical Lead at Humanitarian OpenStreetMap Team.</p> <p>In 2010, Rob's rural volunteer fire department(he is also a long time free software developer for the GNU project, fire-fighter, climber, disaster tech support.) faced the challenge of outdated giant paper mapbooks with incomplete information. Despite Google having limited address and remote road coverage, the lack of cell service made it impossible to rely on it for verification. Determined to find a solution, Rob turned to OpenStreetMap (OSM).  His first step involved importing building footprints and addresses into OSM, greatly aiding the fire department in locating places quickly and easily. The response time was significantly reduced, nearly halved. Given that most of the roads were dirt jeep trails, Rob undertook ground-truthing the highway and trail data in OSM. Over the course of several years, he diligently added precise information about all the highways in his area, enabling the fire department to determine the appropriate response vehicles for each scenario. Once Rob had successfully improved the fire district maps, he expanded his efforts to map the remote regions of Colorado and a few neighboring states, proving invaluable during large wildland fires. Ground-truthing became an integral part of his work, conducted using mobile devices in the field. To streamline the data collection process, Rob heavily relied on OpenDataKit and eventually created additional software to facilitate data processing, which had previously been time-consuming and tedious. Now, transferring data seamlessly from his phone to OSM requires minimal effort. To this day, Rob continues his weekly field mapping every few months while continuously enhancing the software used in the project.</p> <p></p>"},{"location":"#about-osm-fieldwork","title":"About OSM Fieldwork","text":"<p>Osm-Fieldwork is a project for processing data collection using OpenDataKit into OpenStreetMap format. It includes several utility programs that automate part of the data flow like creating satellite imagery basemaps and data extracts from OpenStreetMap so they can be used with ODK Collect. Many of these steps are currently a manual process.  All of the programs in osm-fieldwork are designed to function as the backend of a webpage, but to also work standalone and offline. The standalone functionality are simple command line programs run in a terminal. They were originally created for producing emergency response maps in the Western United States, which is explained in this talk from SOTM-US 2022 titled OSM For Firefighting. Much of the tech and usage is explained in these tech briefs. Currently these are now part of the backend for the Field Mapping Tasking Manager project at HOT.  </p>"},{"location":"#installation","title":"Installation","text":"<p>To install osm-fieldwork, you can use pip. Here are two options:</p> <ol> <li>Directly from the main branch:    <code>pip install git+https://github.com/hotosm/osm-fieldwork.git</code></li> </ol> <p>-OR-</p> <ol> <li>Latest on PyPi:    <code>pip install Osm-Fieldwork</code></li> </ol>"},{"location":"#configure","title":"Configure","text":"<p>Osm-Fieldwork can be configured using a simple config ($HOME/.osm-fieldwork)file in your home directory, or using environment variables.</p>"},{"location":"#config-file","title":"Config file","text":"<p>The config file is used to store the credentials to access an ODK Central server. You must have an account on the Central server of course for this to work. That file looks like this:</p> <pre><code>url=https://foo.org\nuser=foo@bar.org\npasswd=arfood\n</code></pre>"},{"location":"#utility-programs","title":"Utility Programs","text":"<p>These programs are more fully documented in the docs. This is just a short overview.</p> <p>This program converts the data collected from ODK Collect into   the proper OpenStreetMap tagging schema. The conversion is controlled   by an   YAML   file, so easy to modify for other projects. The output are two files,   one is suitable for OSM,and is in OSM XML format. The other   No converted data should ever be uploaded to OSM without validating   the conversion in JOSM. To do efficient conversion from ODK to OSM,   it's best to use the XLSForm library as templates, as everything is   designed to work together.</p> <p>This program creates basemaps of satellite imagery, and produces files   in mbtiles format for ODK   Collect and sqlitedb files   for Osmand. Imagery basemaps are very useful   when the map data is lacking.or in ODK Collect, selecting the current   location instead of where you are standing. The basemaps Osmand are   very useful of navigation where the map data is lacking. Imagery   can be downloaded from   ERSI,   Bing,   USGS Topo maps, or Open   Aerial Map</p> <p>This program makes data extracts from   OpenStreetMap data. Multiple input   sources are supported, a local postgresql database, or the HOT   maintained Underpass database.</p> <p>These programs ER used when working offline for extended periods. This   converts the ODK XML format on your mobile device into the same CSV   format used for submissions downloaded from ODK   Central, or the JSON format   also from Central.</p> <p>This program conflates the data collected by ODK Collect with the   existing OSM data. The output of this file can be loaded into JOSM   for validation and uploading to OpenStreetMap.</p> <p>This program is a simple command line client to an ODK Central   server. This allows you to list projects, appusers, tasks, and   submissions. You can also delete projects, tasks, and appusers, but   this should only be used by   developers   as it does direct database access, and you could lose all your data.</p> <p>This program is used to support humanitariam data models. It extracts   the tags and values from the data models   document   developed by HOT, and compares those to the taginfo database to help   fine tune what data goes into OSM or the private output data. This is   to not flood OSM with obscure tags that aren't supported by the   community. It also filters data extracts so they work with ODK   Collect.</p> <p>This is a silly program, but it takes a GeoJson file, usually an OSM   data extract and generates a GPX file with styling for OsmAnd. This   is useful when ground-truthing map data, as it can be used for   navigating to those areas.</p>"},{"location":"#csvdumppy","title":"CSVDump.py","text":""},{"location":"#basemapperpy","title":"basemapper.py","text":""},{"location":"#make_data_extractpy","title":"make_data_extract.py","text":""},{"location":"#json2osm","title":"json2osm","text":""},{"location":"#odk2csvpy-odk2geojsonpy-odk2osmpy","title":"odk2csv.py, odk2geojson.py, odk2osm.py","text":""},{"location":"#odk_mergepy","title":"odk_merge.py","text":""},{"location":"#odk_clientpy","title":"odk_client.py","text":""},{"location":"#filter_datapy","title":"filter_data.py","text":""},{"location":"#osm2favoritespy","title":"osm2favorites.py","text":""},{"location":"#best-practices-and-troubleshooting","title":"Best Practices and troubleshooting","text":"<p>To ensure the quality of your converted data, here are some best practices to follow:</p> <ul> <li> <p>Always validate your conversion in JOSM before uploading to OpenStreetMap.</p> </li> <li> <p>Use the XLSForm library as templates to ensure that your ODK Collect   data is compatible with the conversion process.</p> </li> <li> <p>If you're having trouble with the conversion process, try using the   utility programs included with Osm-Fieldwork to troubleshoot common   issues.   ) .   For more visit Troubleshooting .   By following these best practices and using the utility programs   included with Osm-Fieldwork, you can effectively process data collection   from OpenDataKit into OpenStreetMap format. However, please note that   while Osm-Fieldwork has been tested and used in various projects, it is   still in active development and may have limitations or issues that   need to be resolved.</p> </li> </ul>"},{"location":"#xlsform-library","title":"XLSForm library","text":"<p>In the XForms directory is a collection of XLSForms that support the new HOT data models for humanitarian data collection. These cover many categories like healthcare, waterpoints, waste distribution, etc... All of these XLSForms are designed to have an efficient mapper data flow, edit existing OSM data, and support the data models.</p> <p></p> <p>The data models specify the preferred tag values for each data item, with a goal of both tag completeness and tag correctness. Each data item is broken down into a basic and extended survey questions when appropriate.</p>"},{"location":"#what-is-an-xlsform","title":"What is an XLSForm?","text":"<p>An XLSForm is a spreadsheet-based form design tool that allows you to create complex forms for data collection using a simple and intuitive user interface. With XLSForms, you can easily design and test forms on your computer, then deploy them to mobile devices for data collection using ODK Collect or other data collection tools. XLSForms use a simple and structured format, making it easy for you to share and collaborate on form designs with your team or other organizations.</p>"},{"location":"#using-the-xlsform-library-with-osm-fieldwork","title":"Using the XLSForm Library with Osm-Fieldwork","text":"<p>The XLSForms in the XForms directory of the XLSForm Library have been designed to support the HOT data models and have an efficient mapper data flow. These forms also allow for editing of existing OSM data and support the data models, specifying the preferred tag values for each data item with the goal of both tag completeness and tag correctness.</p>"},{"location":"#here-are-some-examples-of-how-to-use-the-xlsform-library-with-osm-fieldwork","title":"Here are some examples of how to use the XLSForm Library with Osm-Fieldwork:","text":"<ul> <li>Download an XLSForm from the XForms directory:</li> </ul> <p>wget https://github.com/hotosm/xlsform/raw/master/XForms/buildings.xls</p> <ul> <li> <p>Convert the XForm to OSM XML using CSVDump:</p> </li> <li> <p>Use the resulting OSM XML file with JOSM or other OSM editors to   validate and edit the data before uploading it to OpenStreetMap.</p> </li> </ul>"},{"location":"#conclusion","title":"Conclusion","text":"<p>The XLSForm Library is a valuable resource for organizations involved in humanitarian data collection, as it provides a collection of pre-designed forms that are optimized for efficient mapper data flow and tag completeness/correctness. By using the XLSForm Library with Osm-Fieldwork, you can streamline your data collection process and ensure the quality of your data.</p> <p>Osm-Fieldwork is a powerful tool for processing data collection from OpenDataKit into OpenStreetMap format. By following the best practices outlined in this documentation and using the utility programs included with Osm-Fieldwork, you can streamline your data collection process and ensure the quality of your converted data. If you have any questions or issues with osm-fieldwork, please consult the project's documentation or seek support from the project's community.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#036rc2-2023-09-11","title":"0.3.6rc2 (2023-09-11)","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>json2osm handle polygons and points (#192)</li> <li>Update raw-osmdata to 0.1.1</li> <li>add osm-rawdata dependency</li> <li>Major refactoring to use the new osm-rawdata module</li> <li>Add join_or tag which is now required in the enhanced YAML format</li> <li>Use optional env variable for the raw data API</li> <li>initialize variable</li> <li>Arg, change the raw data URI again</li> <li>json2osm calling via api</li> <li>The URL for raw data has changed</li> <li>Add config file for waterways</li> </ul>"},{"location":"CHANGELOG/#036rc1-2023-09-07","title":"0.3.6rc1 (2023-09-07)","text":""},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>json2osm via cmdline + programatically</li> </ul>"},{"location":"CHANGELOG/#036rc0-2023-09-01","title":"0.3.6rc0 (2023-09-01)","text":""},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>complete overhaul of docs, mkdocstrings</li> </ul>"},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>csv parsing for test</li> <li>Delete the UML images for clean</li> <li>Generate PDFs from the primary markdown files in docs/about</li> <li>Drop unused main.py file</li> <li>Add support for doxygen API docs</li> <li>fix typo in url for data flow diagram</li> <li>Add new data flow charts</li> <li>Use new imagery.yaml file for sources instead of hardcoding them all</li> <li>Add USGS topo map as a source</li> <li>Improve parsing to cover more than one format</li> <li>Add support for a custom TMS URL</li> <li>Add missing test data file</li> <li>Improve processing of Rwanda submissions, capture OSM ID and improve the conversion config file</li> <li>list forms api</li> <li>filespec made optional in the filterdata class</li> <li>text 78 was present, it is now removed</li> <li>indentation on odk_merge</li> <li>typing issues and imports</li> <li>Fix listForms(), the parameter name changed</li> <li>Add trailing comma to all function parameter blocks</li> <li>Add the deep tech docs</li> <li>fix typo in parameter name</li> <li>Add the more obscure utilities to the API docs</li> <li>Add more API wrappers</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Fix broken indent in debugging code, it was only being executed with -v</li> <li>Add standalone script for osm2favorites</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Add mkdocs code comments</li> <li>Add mkdocs comments</li> <li>Add mkdocs code comments</li> <li>Add bash wrapper for basemapper.py</li> <li>Update a few mkdocs comments so mkdocs serve is happy</li> <li>Minor updates to mkdoc comment, fix indentation</li> <li>Add mkdocs code comments</li> <li>Add more docs, organize top level links</li> <li>Replace lines of code that got deleted by accident</li> <li>Add mkdoc strings</li> <li>creating a project that already exists</li> <li>Add pySmartDL</li> </ul>"},{"location":"CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li>update refs logging --&gt; log</li> <li>remove mkgendocs config</li> </ul>"},{"location":"CHANGELOG/#035-2023-08-11","title":"0.3.5 (2023-08-11)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>Add mercantile</li> <li>indentation error in basemapper</li> </ul>"},{"location":"CHANGELOG/#034-2023-08-06","title":"0.3.4 (2023-08-06)","text":""},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>get extended details of a project</li> <li>get form full details</li> <li>Handle geometries better in the other json variant from Central</li> </ul>"},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>Improve methods to test data contents for tags</li> <li>Add more real tests</li> <li>conflateThread() takes an additional argument now</li> <li>Add some real tests for conversion</li> <li>Add test data for JSON to OSM conversion</li> <li>disable warnings from depenancies when running pytest</li> <li>getAllSubmissions() now takes an optional argument, which is the list of XForms</li> <li>Use flatfic module instead of traversing it ourselves</li> <li>comment out debug message</li> <li>handle uid/user in attrs better</li> <li>add flatdict module</li> <li>use a flattened dictionary instead of traversing everything ourselves</li> <li>use lower case for string matching, it's faster than fuzzy matching</li> <li>Minor update</li> <li>all tags should be in lower case</li> <li>if node is not present, return False in loadFIle in osmfile class</li> <li>load file in osmfile class</li> <li>no of threads missing some data at the end</li> <li>Add comment on commented out code block</li> <li>Drop escaping - in regex</li> <li>Trap bad auth with the ODK Central server</li> <li>Add timer to see how long it takes to process the data</li> <li>Add support to download all submissions for all tasks in a project</li> <li>Remove large block of commented out code</li> <li>Add support to download all submissions for all tasks in a project</li> <li>main, not moon</li> <li>Add new XLSForm for highways</li> <li>chunk set to 1 when the chunk value is 1</li> <li>fix indenting mistake that prevented display forms</li> <li>Add support to the underpass query to return linestrings</li> <li>Add support for highways</li> <li>handle XLSForms that don't use a data extract</li> <li>Add support for highways</li> <li>highways use ways_line, not ways_poly</li> <li>Add config file for highway query</li> </ul>"},{"location":"CHANGELOG/#033-2023-07-25","title":"0.3.3 (2023-07-25)","text":""},{"location":"CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li>uncomment my stupid mistakes</li> <li>Add the new conflatin doc to the sidebar</li> <li>Add doc on how this project does conflation</li> <li>fix minor type</li> <li>Add make_data_extract to scripts</li> <li>Add more content</li> <li>Now that there are multiple postgres connections, clip all of them</li> <li>Handle no data returned errors</li> <li>Addd main() so it can be called when run standalone</li> <li>Add standalone scripts so all programs can be run from the install package</li> <li>Fix type in maion</li> <li>make a main function to they can run standalone</li> <li>Add a main function to this can run standalone from the installed python package</li> <li>Add new user manual to the sidebar</li> <li>Add new user manual</li> <li>Refactor to use an array of database connections, one for each thread to avoid proble</li> <li>Not all data has a timestamp, and it gets set anyone to the current time</li> <li>Major refactoring to support conflation with either postgis or the data extract used for FMTM</li> <li>keep more tags for the output file</li> <li>add more tags to keep for the output file</li> <li>Add newline after writing </li> <li>Add government_menu to ignore</li> <li>Add tests for conflating with a database</li> <li>Add test prpoject boundary</li> <li>Improve test cases so they can find the test data files under pytest</li> <li>Update test data, and add test case for odk_merge</li> <li>Add section on importing the data into postgres</li> <li>use log so it works in FMTM, get the feature version in SQL queries</li> <li>Add support for using a GeoJson data extract as the conflation source</li> <li>Implement writing the OSM XML output file</li> <li>There are weird capitalization in the keywords</li> <li>Put the modified warning in a note instead of fixme</li> <li>Handle errors if there is no forms or project</li> <li>handle xlsfile better</li> <li>osmfile.footer() is now called by a destructor</li> <li>Don't escape spaces</li> <li>Implement conflating a POI against ways</li> <li>Add a destructor so the footer gets added when class is deleted</li> <li>Make output file optional</li> <li>Conversion from gdal is done, startin gto implement threads</li> <li>output files go into current dir, not /tmp</li> <li>escape is now a standalone function</li> <li>Make infile a required argument</li> <li>escape is now a standalone function so it can be used by other classes</li> <li>Update test cases since now data files get installed</li> <li>Add function for parsing database URIs, add test case for URI parser</li> <li>parse the OSM XML file if the data is in a dict</li> <li>THis gets processed lower down, so this is duplicate code</li> <li>Don't pass bogus config file</li> <li>Fix support to use Google imagery</li> <li>Fix support for bing imagery</li> <li>Update section on setting the default in Collect from OSM data</li> <li>Drop outfile from calling PostgresClient()</li> <li>Add roof:shape and roof:levels to keep</li> <li>Add shop to keep</li> </ul>"},{"location":"CHANGELOG/#032-2023-06-27","title":"0.3.2 (2023-06-27)","text":""},{"location":"CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>Convert the currt JSON format as downloaded from FMTM</li> <li>Fix processing of the ignore section</li> <li>Always write the value as a sting</li> <li>Remove the sldes.xls file</li> <li>Also use an optional user and password for database access</li> </ul>"},{"location":"CHANGELOG/#031-2023-06-21","title":"0.3.1 (2023-06-21)","text":""},{"location":"CHANGELOG/#fix_7","title":"Fix","text":"<ul> <li>For polygons in the data file, just use the centroids</li> <li>Add one to the ending zoom level so range() stops loosing the last zoom level</li> <li>Display usage() if no arguments are given</li> <li>Add qualifiers to limit the shops that get returned</li> </ul>"},{"location":"CHANGELOG/#031rc2-2023-06-01","title":"0.3.1rc2 (2023-06-01)","text":""},{"location":"CHANGELOG/#fix_8","title":"Fix","text":"<ul> <li>Add utility that generates a fovorites file for Osmand</li> <li>Trap error for no output file and print usage()</li> <li>Add accuracy to ignore section</li> <li>Fix message in usage</li> <li>Added Osmand extensions for styling the favorites</li> <li>Write GPX file with Osmand specific styling</li> <li>Convert a GeoJson file into a favorites.gpx file for Osmand complete with all the tags</li> <li>Delete geometry tag from input datata stream so it doesn't casue confusion later</li> <li>Add support for processing either GeoJson (usually from odk2geojson) or JSON from Central</li> <li>Make timestamp for filename longer</li> <li>Change gosm to osm-fieldwork. Oops</li> <li>New program that converts the ODK XML instance files off your phone and turns it into good GeoJson for JOSM</li> <li>Disable debug message</li> <li>Major refactoring, it actually works now</li> <li>Always grab all the submissions</li> </ul>"},{"location":"CHANGELOG/#refactor_1","title":"Refactor","text":"<ul> <li>improve logging for OdkCentral + createProject</li> </ul>"},{"location":"CHANGELOG/#031rc1-2023-05-18","title":"0.3.1rc1 (2023-05-18)","text":""},{"location":"CHANGELOG/#fix_9","title":"Fix","text":"<ul> <li>xform in getSubmissions function</li> <li>output file in osm extracts</li> <li>add a default value</li> <li>use type for parameters to methods</li> <li>Use type for all parameters to methods</li> <li>conversion now returns a dict</li> <li>Remove accidental map-icons submodule, use types with all method parameters</li> <li>Drop paren</li> <li>Use line not linestring as a type, turn data into a dict from queryRemote()</li> <li>Default to using the underpass database for raw OSM data</li> <li>Remove debug message</li> <li>Add XLSForms for camping and small town amenity mapping</li> <li>Changes made while camping, mostly minor tweaks</li> <li>Remove stamp file</li> <li>Extract the metadata from the XLSForm</li> <li>Use the warmup location if there isn't one for the geopoint</li> <li>Add json as an input source</li> <li>Download the josn file of submissions from Central</li> <li>add more tags to ignore</li> <li>Process the json file from Central and write OSM XML and Geojsaon files</li> <li>return a dict instead of a list</li> <li>Convert the JSON fike from ODATA into OSM</li> <li>Process the defaults from the XLSFile</li> <li>process all rows to get the fields, as not all files have the same ones</li> <li>COnvert openfire tpo leisure=firepit, which is more common</li> <li>If the extract would be empty, write dummy entry so ODK Collect will still launch</li> <li>Fix logging</li> <li>Write dummy geojson file if there ios nothing in the extract</li> <li>fix logging setup, readoing CSV file</li> <li>use yaml as the config file if it exists</li> <li>Add support for generating variants of an XLSForm</li> <li>Add new non humanitarian XLSForms</li> <li>add support for amenities XLSForm</li> <li>Update the column names in all XLSForms to use the same name so they can all be scanned for the title and ID</li> <li>Add config file for amenities</li> <li>Add XLSForm for historical sites</li> <li>When querying a local database, collect all results</li> <li>Add support for new camping form</li> <li>refactor the groups of survey questions</li> <li>Add OSM map-icons as submodule</li> <li>fix typo in comment</li> </ul>"},{"location":"CHANGELOG/#031rc0-2023-05-04","title":"0.3.1rc0 (2023-05-04)","text":""},{"location":"CHANGELOG/#fix_10","title":"Fix","text":"<ul> <li>got queryLocal(), get all the nodes and ways</li> <li>Process ODK_CENTRAL_SECURE correctly as the value from the end is a string, but the default is a bool</li> <li>Updates to layout, play with fancy colors</li> <li>Add method to extract the data extract filename, the XLSFOrm ID, and the XLSForm title from the spreadsheet</li> <li>Make default values work so we don't break the FMTM frontend</li> <li>Add content about name conflicts when using data extracts</li> <li>delete downloaded zip file after extracting the data file</li> <li>Implement uploading to Central</li> <li>minor changes</li> <li>Fix xform target and suffix rules to work with the name changes to avoid conflicts with OSM tags</li> <li>rename to avoid name conflict with OSM tag</li> <li>Fix typo in keyword</li> <li>Rename place to places to avoid a name conflict with an OSM tag</li> <li>when run standalone, the xform doesn't have to be changed, and fix wrong error message</li> <li>Updated so all the columns are in the same order, cleanup high lighting</li> <li>minor formatting changes</li> <li>rename t oplaces to avoid a conflict with the OSM place tag</li> <li>The yaml config filenane should match the xlsform, not the category</li> <li>rename file to avoid a nanme conflict with healthcare OSM tag</li> <li>Extract the XForm title and the name of the data extract from the XLSFoem</li> <li>Filter the types of waste amenities wanted, otherwise we get all amenities</li> <li>Rename to avoid naming conflicts with an OSM tag</li> <li>Rename natural to nature to avoid name conflicts with OSM</li> <li>Make the XLSForm for a category configurable via a YAML file to avoid name conflicts</li> <li>renamed to avoid a name conflict with the waste OSM tag</li> <li>rename landuse.yaml to landusage to avoid a name conflict with the landuse tag</li> <li>Add support to generate data extracts for all categories for testing</li> <li>rename landude.xls to landusage so the name doesn't conflict with the tag</li> <li>Update to support OSM data extracts, a few tewaks for the data models</li> <li>Add tag values to json file for remote database queries</li> <li>Improve command line for polygon vs centroid</li> <li>Enable reding tags to keep from yaml file</li> <li>Optionally output polygons instead of centroids when using a local postgres database</li> <li>Use python package to find xforms.yaml file</li> <li>Fix test cases to work with pythohn package</li> <li>add healthcare_type</li> <li>use list_name with an underbar instead of space</li> <li>Updated to support data extracts</li> <li>Make the OSM tags to keep configurable in the yaml file</li> <li>When reading an environment variable that is a boolean, convert the string to a bool</li> <li>Add nsupport to extract either polygons of centroids. Add boundary polygon to the extract</li> <li>Support a option to specify the path to the taginfo db and output csv</li> <li>Update file with YAML file syntax and examples</li> <li>Update docs, some content pulled into new files</li> <li>Refacor the programs.md file, move large detailed content into there own files</li> </ul>"},{"location":"CHANGELOG/#020-2023-03-31","title":"0.2.0 (2023-03-31)","text":""},{"location":"CHANGELOG/#feat_2","title":"Feat","text":"<ul> <li>rename repo odkconvert --&gt; osm-fieldwork</li> </ul>"},{"location":"CHANGELOG/#fix_11","title":"Fix","text":"<ul> <li>For querying Overpass, use either a file or a geojson dict</li> <li>fix merge conflicts</li> <li>Merge documentation changes from development branch</li> <li>modified all files, replacing odkconvert wth osm-fieldwork</li> <li>Add overpy</li> <li>Minor typo fix</li> <li>Refactor and update</li> </ul>"},{"location":"CHANGELOG/#011-2023-03-29","title":"0.1.1 (2023-03-29)","text":""},{"location":"CHANGELOG/#fix_12","title":"Fix","text":"<ul> <li>Refactor and update</li> </ul>"},{"location":"CHANGELOG/#010-2023-03-25","title":"0.1.0 (2023-03-25)","text":""},{"location":"CHANGELOG/#feat_3","title":"Feat","text":"<ul> <li>set ssl verify via environment variable, default true</li> <li>option to configure standalone odkconvert via env vars</li> <li>index for xform files, plus path</li> </ul>"},{"location":"CHANGELOG/#fix_13","title":"Fix","text":"<ul> <li>update logging</li> <li>listProjects and findAppUser methods for OdkCentral, update logging</li> <li>relative imports --&gt; absolute imports for packaging</li> <li>update verify=True for urllib to verify certs</li> <li>allow listProjects to fail gracefully if none exist</li> <li>typo for religious</li> <li>makefile zip bundle, pyproject version attr</li> <li>update paths for xforms.yaml, fix CSVDump.parse</li> </ul>"},{"location":"CHANGELOG/#refactor_2","title":"Refactor","text":"<ul> <li>rename xforms to xlsforms throughout code</li> <li>rename xform dir to xlsform, more descriptive</li> <li>rename xforms path var for clarity</li> <li>remove redundant csv output files from xforms</li> <li>update refs to xforms dir and odk_client.py</li> <li>rename XForms dir to lowercase xforms</li> <li>add includes to pyproject to bundle odkconvert dir</li> <li>missed yaml file for restructure</li> <li>rename test dir to pytest default (tests)</li> <li>restructure, move .py files to odkconvert dir</li> </ul>"},{"location":"Code-of-Conduct/","title":"Code of conduct","text":"<p>(The latest version can be found at https://www.hotosm.org/code-of-conduct)</p> <p>Welcome to Humanitarian OpenStreetMap Team. HOT is committed to providing a welcoming and safe environment for people of all races, gender identities, gender expressions, sexual orientations, physical abilities, physical appearances, socio-economic backgrounds, nationalities, ages, religions, and beliefs.</p> <p>The HOT community principles are:</p> <p>Be friendly and patient. Be generous and kind in both giving and accepting critique. Critique is a natural and important part of our culture. Good critiques are kind, respectful, clear, and constructive, focused on goals and requirements rather than personal preferences. You are expected to give and receive criticism with grace. Be considerate in speech and actions, and actively seek to acknowledge and respect the boundaries of fellow attendees.</p> <p>Be welcoming. We strive to be a community that welcomes and supports people of all backgrounds and identities. Some examples of behavior that contributes to creating a positive environment include:</p> <ul> <li> <p>Using welcoming and inclusive language.</p> </li> <li> <p>Being respectful of differing viewpoints and experiences.</p> </li> <li> <p>Gracefully accepting constructive criticism.</p> </li> <li> <p>Showing empathy towards other community members.</p> </li> <li> <p>Placing collective interest before your own interest.</p> </li> </ul> <p>Be considerate. Your work will be used by other people, and you in turn will depend on the work of others. Any decision you take will affect users and colleagues, and you should take those consequences into account when making decisions. Remember that we're a world-wide community, so you might not be communicating in someone else's primary language.</p> <p>Be respectful. Not all of us will agree all the time, but disagreement is no excuse for poor behavior and poor manners. We might all experience some frustration now and then, but we cannot allow that frustration to turn into a personal attack. It\u2019s important to remember that a community where people feel uncomfortable or threatened is not a productive one. Members of the HOT community should be respectful when dealing with other members as well as with people outside the HOT community.</p> <p>Be careful in your word choice. We are a global community of professionals, and we conduct ourselves professionally. Be kind to others. Do not insult or put down other participants. Harassment and other exclusionary behavior aren't acceptable. This includes, but is not limited to:</p> <ul> <li> <p>Violent threats or language directed against another person.</p> </li> <li> <p>Discriminatory jokes and language.</p> </li> <li> <p>Posting sexually explicit or violent material.</p> </li> <li> <p>Posting (or threatening to post) other people's personally identifying information (\"doxing\").</p> </li> <li> <p>Personal insults, especially those using racist or sexist terms.</p> </li> <li> <p>Unwelcome sexual attention.</p> </li> <li> <p>Advocating for, or encouraging, any of the above behavior.</p> </li> <li> <p>Repeated harassment of others. In general, if someone asks you to stop, then stop.</p> </li> </ul> <p>Assume all communications are positive. Always remain polite, and assume good faith. It is surprisingly easy to misunderstand each other, be it online or in person, particularly in such a culturally diverse setting as ours. Misunderstandings are particularly easy to arise when we are in a rush, or otherwise distracted. Please ask clarifying questions before assuming that the communication was inappropriate.</p> <p>When we disagree, try to understand why. Disagreements, both social and technical, happen easily and often. It is important that we resolve such disagreements and differing views constructively. At times it can be hard to appreciate a viewpoint that contradicts your own perceptions. Instead of pushing back, try to understand where the other person is coming from, and don\u2019t be afraid to ask questions. You can be most helpful if your own replies serve to clarify, rather than to escalate an issue. Also don\u2019t forget that it can be easy to make mistakes, and allow for the possibility that the mistake may have been yours. When this happens it is better to resolve the issue together, and to learn from the experience together, than to place blame.</p> <p>Original text courtesy of the Speak Up! project.</p> <p>Further sources:</p> <ul> <li> <p>Ada Initiative: HOWTO design a code of conduct for your community</p> </li> <li> <p>Algorithm Club Code of Conduct</p> </li> <li> <p>American Red Cross GIS Team Code of Conduct</p> </li> <li> <p>Contributor Covenant \u2013 A Code of Conduct for Open Source Projects</p> </li> <li> <p>Django Code of Conduct</p> </li> <li> <p>Mozilla Community Participation Guidelines</p> </li> <li> <p>Vox Media Code of Conduct</p> </li> </ul>"},{"location":"Code-of-Conduct/#complaint-handling-process","title":"Complaint Handling Process","text":"<p>As a first measure, it is preferable to work out issues directly with the people involved or to work with other Community Members who can help you resolve the issue. This may take several forms:</p> <ul> <li> <p>Talk with one another. Assume that communications are positive and that people are treating each other with respect. Cues about emotions are often lacking in digital communications. Many of our modes of digital communication tend towards brevity, which can be easier to interpret incorrectly as being negative.</p> </li> <li> <p>Contact a representative of the Community Working Group, which exists to support the HOT Community. Representatives are available to discuss any concerns about behaviour within the community, or ideas to promote positive behaviours. You can email them at community@hotosm.org.</p> </li> <li> <p>Contact a representative of the Governance Working Group, which drafted these recommendations and the CoC. Representatives are available to provide advice on particular scenarios, as well as on the processes around the CoC.</p> </li> <li> <p>Contact the HOT Chair of Voting Members.</p> </li> <li> <p>Contact a HOT Board Member. Board members are well-versed in the community and its management. They can offer advice on your particular situation, and know the resources of the organization that may be available to you.</p> </li> <li> <p>Contact the HOT Community Partnerships Manager.</p> </li> </ul> <p>When these informal processes fail, or when a situation warrants an immediate response by HOT, you can evoke the HOT Policy and Code of Conduct Complaint Handling Process. This process was adopted by HOT Voting Members in 2016 to provide a more formal means of enforcement for our community standards. You start it by emailing complaints@hotosm.org with a description of your complaint, your name, and the name of the offending party. All complaints will be considered confidential. The full process is described here</p>"},{"location":"LICENSE/","title":"GNU GENERAL PUBLIC LICENSE","text":"<p>Version 3, 29 June 2007</p> <p>Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</p> <p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>"},{"location":"LICENSE/#preamble","title":"Preamble","text":"<p>The GNU General Public License is a free, copyleft license for software and other kinds of works.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too.</p> <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others.</p> <p>For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.</p> <p>Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it.</p> <p>For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions.</p> <p>Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users.</p> <p>Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p>"},{"location":"LICENSE/#terms-and-conditions","title":"TERMS AND CONDITIONS","text":""},{"location":"LICENSE/#0-definitions","title":"0. Definitions","text":"<p>\"This License\" refers to version 3 of the GNU General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p>"},{"location":"LICENSE/#1-source-code","title":"1. Source Code","text":"<p>The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p>"},{"location":"LICENSE/#2-basic-permissions","title":"2. Basic Permissions","text":"<p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p>"},{"location":"LICENSE/#3-protecting-users-legal-rights-from-anti-circumvention-law","title":"3. Protecting Users' Legal Rights From Anti-Circumvention Law","text":"<p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p>"},{"location":"LICENSE/#4-conveying-verbatim-copies","title":"4. Conveying Verbatim Copies","text":"<p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p>"},{"location":"LICENSE/#5-conveying-modified-source-versions","title":"5. Conveying Modified Source Versions","text":"<p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <p>a) The work must carry prominent notices stating that you modified it, and giving a relevant date.</p> <p>b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\".</p> <p>c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it.</p> <p>d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so.</p> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p>"},{"location":"LICENSE/#6-conveying-non-source-forms","title":"6. Conveying Non-Source Forms","text":"<p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <p>a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange.</p> <p>b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge.</p> <p>c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b.</p> <p>d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements.</p> <p>e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d.</p> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p>"},{"location":"LICENSE/#7-additional-terms","title":"7. Additional Terms","text":"<p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <p>a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or</p> <p>b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or</p> <p>c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or</p> <p>d) Limiting the use for publicity purposes of names of licensors or authors of the material; or</p> <p>e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or</p> <p>f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors.</p> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p>"},{"location":"LICENSE/#8-termination","title":"8. Termination","text":"<p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p>"},{"location":"LICENSE/#9-acceptance-not-required-for-having-copies","title":"9. Acceptance Not Required for Having Copies","text":"<p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p>"},{"location":"LICENSE/#10-automatic-licensing-of-downstream-recipients","title":"10. Automatic Licensing of Downstream Recipients","text":"<p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p>"},{"location":"LICENSE/#11-patents","title":"11. Patents","text":"<p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p>"},{"location":"LICENSE/#12-no-surrender-of-others-freedom","title":"12. No Surrender of Others' Freedom","text":"<p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p>"},{"location":"LICENSE/#13-use-with-the-gnu-affero-general-public-license","title":"13. Use with the GNU Affero General Public License","text":"<p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such.</p>"},{"location":"LICENSE/#14-revised-versions-of-this-license","title":"14. Revised Versions of this License","text":"<p>The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p>"},{"location":"LICENSE/#15-disclaimer-of-warranty","title":"15. Disclaimer of Warranty","text":"<p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p>"},{"location":"LICENSE/#16-limitation-of-liability","title":"16. Limitation of Liability","text":"<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>"},{"location":"LICENSE/#17-interpretation-of-sections-15-and-16","title":"17. Interpretation of Sections 15 and 16","text":"<p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"LICENSE/#how-to-apply-these-terms-to-your-new-programs","title":"How to Apply These Terms to Your New Programs","text":"<p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre>\n\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful, but\nWITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.\n\n\n<p>Also add information on how to contact you by electronic and paper mail.</p>\n<p>If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:</p>\n<pre>\n&lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\nThis program comes with ABSOLUTELY NO WARRANTY; for details\ntype `show w'.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions; type `show c' for details.\n</pre>\n\n<p>The hypothetical commands <code>show w</code> and <code>show c</code> should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\".</p>\n<p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see &lt;http://www.gnu.org/licenses/&gt;.</p>\n<p>The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read &lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.</p>"},{"location":"about/About/","title":"About","text":""},{"location":"about/About/#osm-fieldwork-project","title":"OSM-Fieldwork Project","text":"<p>Osm_Fieldwork is a project that aims to simplify the process of processing data collected using OpenDataKit into OpenStreetMap format. It consists of several utility programs that automate different parts of the data flow. These include creating satellite imagery basemaps and data extracts from OpenStreetMap so they can be used with ODK Collect. It is maintained by the Humanitarian OpenStreetMap Team (HOT) and designed to work with ODK Collect, an Android app for data collection, and ODK Central, a web-based platform for managing and visualizing data.</p>"},{"location":"about/About/#osm_fieldwork","title":"osm_fieldwork","text":"<p>This program converts the data collected from ODK Collect into the proper OpenStreetMap tagging schema. The conversion is controlled by a YAML file, which makes it easy to modify for other projects. The output is an OSM XML formatted file for JOSM. However, it is important to note that no converted data should ever be uploaded to OSM without first validating the conversion in JOSM. To do high-quality conversion from ODK to OSM, it's best to use the XLSForm library as template, as everything is designed to work together.</p> <p>Osm_Fieldwork includes the following utilities:</p> <ul> <li><code>make_data_extract.py</code>: extracts OpenStreetMap data within a given boundary and category (e.g., buildings, amenities) using Overpass Turbo or a Postgres database.</li> <li><code>CSVDump.py</code>: converts a CSV file downloaded from ODK Central to OSM XML format.</li> <li><code>odk2csv.py</code>: converts an ODK XML instance file to the same CSV format used by ODK Central.</li> <li><code>ODKDump.py</code>: extracts data from an ODK Collect instance XML file and converts it to OSM XML format.</li> <li><code>ODKForm.py</code>: parses an ODK XML form file and extracts its fields and data types.</li> <li><code>ODKInstance.py</code>: parses an ODK Collect instance XML file and extracts its fields and data values.</li> </ul> <p>Osm_Fieldwork also includes support modules, such as convert.py for processing YAML config files and osmfile.py for writing OSM XML output files.</p>"},{"location":"about/About/#installation","title":"Installation","text":"<p>To install osm-fieldwork, you can use pip. Here are two options:</p> <ol> <li>Directly from the main branch:   <code>pip install git+https://github.com/hotosm/osm-fieldwork.git</code></li> </ol> <p>-OR-</p> <ol> <li>Latest on PyPi:   <code>pip install Osm-Fieldwork</code></li> </ol> <p>Note: installation requires GDAL &gt;3.4 installed on your system.</p>"},{"location":"about/About/#usage","title":"Usage","text":"<p>Each utility has its own command-line interface, with various options and arguments. You can find detailed instructions on how to use each utility by running it with the -h or --help option. For example, to extract OSM data within a boundary polygon from Overpass Turbo, run:</p> <p><code>./make_data_extract.py --overpass --boundary mycounty.geojson</code></p> <p>This will create a GeoJSON file with the extracted data.</p> <p>To convert a CSV file from ODK Central to OSM XML format, run:</p> <p><code>./CSVDump.py -i data.csv</code></p> <p>This will generate two output files - one OSM XML of public data, and the other a GeoJson file with all the data.</p>"},{"location":"about/About/#contributing","title":"Contributing","text":"<p>Osm_Fieldwork is an open-source project, and contributions are always welcome! If you want to contribute, please read the Contribution Guidelines and Code of Conduct first.</p>"},{"location":"about/About/#license","title":"License","text":"<p>Osm_Fieldwork is released under the AGPLv3.</p>"},{"location":"about/CSVDump/","title":"CSVDump","text":""},{"location":"about/CSVDump/#csvdumppy","title":"CSVDump.py","text":"<p>CSVDump.py is a Python script that converts a CSV file downloaded from ODK Central to OpenStreetMap (OSM) XML format. The tool can be useful for users who want to work with OpenStreetMap data and want to convert ODK Central data into a compatible format.</p> <pre><code>options:\n -h, --help                   - show this help message and exit\n -v, --verbose                - verbose output\n -i CSVFILE, --infile CSVFILE - Specifies the path and filename of the input CSV file downloaded from ODK Central. This option is required for the program to run.\n</code></pre>"},{"location":"about/CSVDump/#examples","title":"Examples:","text":"<p>To convert a CSV file named \"survey_data.csv\" located in the current working directory, the following command can be used:</p> <pre><code>[path]/CSVDump.py -i survey_data.csv\n</code></pre> <p>To enable verbose output during the conversion process, the following command can be used:</p> <pre><code>[path]/CSVDump.py -i survey_data.csv -v\n</code></pre>"},{"location":"about/CSVDump/#input-format","title":"Input Format:","text":"<p>CSVDump.py expects an input file in CSV format downloaded from ODK Central. The CSV file should have a header row with column names that correspond to the survey questions. Each row in the CSV file should contain a response to the survey questions, with each column representing a different question.</p>"},{"location":"about/CSVDump/#output-format","title":"Output Format:","text":"<p>The output of CSVDump.py is an OSM XML file that can be used with OpenStreetMap data tools and services. The converted OSM XML file will have tags for each survey question in the CSV file, as well as any metadata associated with the survey. The format of the OSM XML file generated by CSVDump.py is compatible with other OpenStreetMap data tools and services.</p>"},{"location":"about/CSVDump/#limitations","title":"Limitations:","text":"<ul> <li>CSVDump.py only supports CSV files downloaded from ODK   Central. Other CSV files may not be compatible with the tool.</li> <li>The tool only supports simple data types such as strings, numbers,   and dates. Complex data types such as arrays and nested structures   are not supported.</li> </ul>"},{"location":"about/Contribution/","title":"Contribution","text":""},{"location":"about/Contribution/#hugs-welcome","title":":hugs: Welcome","text":"<p> First off, I'm really glad you're reading this, because we need volunteer developers to help improve the Osm_Fieldwork and it's integration with FMTM! </p> <p>We welcome and encourage contributors of all skill levels and we are committed to making sure your participation is inclusive, enjoyable and rewarding. If you have never contributed to an open source project before, we are a good place to start and will make sure you are supported every step of the way. If you have any questions, please ask!</p> <p>There are many ways to contribute to this repo:</p>"},{"location":"about/Contribution/#testing","title":"Testing","text":"<p>Adding test cases, or simply testing out existing functionality.</p>"},{"location":"about/Contribution/#report-bugs-and-suggest-improvements","title":"Report bugs and suggest improvements","text":"<p>The issue queue is the best way to get started. There are issue templates for BUGs and FEATURES that you can use, or you can create your own. Once you have submitted an issue, it will be assigned one label out of the following label categories. If you are wondering where to start, you can filter by the GoodFirstIssue label.</p>"},{"location":"about/Contribution/#code-contributions","title":"Code contributions","text":"<p>Create pull requests (PRs) for changes that you think are needed. We would really appreciate your help!</p>"},{"location":"about/Contribution/#useful-resources-for-contribution","title":"Useful Resources for Contribution","text":"<ul> <li>Troubleshooting</li> <li>FAQs</li> </ul>"},{"location":"about/Contribution/#thank-you","title":"Thank you","text":"<p>Thank you very much in advance for your contributions!! Please ensure you refer to our Code of Conduct. If you've read the guidelines, but you are still not sure how to contribute on Github, please reach out to us via our Slack #geospatial-tech-and-innovation.</p>"},{"location":"about/FAQ/","title":"\u2753 Frequently Asked Questions \u2753","text":"<p>Q: What is OSM Fieldwork?</p> <p>A: OSM Fieldwork is a project to support field data collection using OpenDataKit and OpenStreetMap. The primary functionality is the ability to convert data collected with ODK Collect into OSM XML. In addition it can also create satellite imagery basemaps for ODK Collect and Osmand. In addition there is a library of XLSForms focused on humanitarian data collection.</p> <p>Q: How do I install OSM Fieldwork ?</p> <p>A: To install osm-fieldwork, you can use pip. Here are two options:</p> <ol> <li>Directly from the main branch:   <code>pip install git+https://github.com/hotosm/osm-fieldwork.git</code></li> </ol> <p>-OR-</p> <ol> <li>Latest on PyPi:   <code>pip install Osm-Fieldwork</code></li> </ol> <p>Q: Where can I find the source code and the XLSForm library ?</p> <p>A: Check the osm-fieldwork git repo here</p> <p>Q: What language is Osm Fieldwork written in ?</p> <p>A: OSM Fieldwork is written in Python and uses other modules like shapely, pyxform, xmltodict, psycopg2, and pandas</p> <p>Q: What is the XLSForm library ?</p> <p>A: The library of XLSForms are primarily focused on humanitarian data collection, and follow data models designed by the Humanitarian Openstreetmap Team with consultation with other humanitarian NGOs. These are designed for efficient data collection and conversion to OSM XML format to allow for easy and high quality contributions to the map.</p> <p>Q: Who can contribute to osm-fieldwork?</p> <p>A: It is an open-source project, and contributions from developers and technical writers are always welcome.</p> <p>Q: What kind of contributions can I make ?</p> <p>A: There are several ways you can contribute to osm-fieldwork, including:</p> <ul> <li> <p>Development: If you have experience in development, you can contribute by fixing bugs, adding new features, or improving the existing codebase.</p> </li> <li> <p>Documentation: If you have experience in technical writing, you can contribute by writing documentation, tutorials, or other educational materials.</p> </li> <li> <p>Testing: If you have experience in software testing, you can contribute by testing the application and reporting bugs or suggesting improvements.</p> </li> </ul> <p>Q: How can I report a bug or suggest a new feature for OSM   Fieldwork ?</p> <p>A: You can report bugs or suggest new features by opening an issue   on the OSM Fieldwork   repository on   GitHub. Be sure to provide as  much detail as possible, including   steps to reproduce the bug and any relevant error messages.   For more details visit Contributions Page.</p> <p>Q: Do I need to have prior experience with XLSForms or python to contribute to OSM Fieldwork ?</p> <p>A: While prior experience with the various data formats usd by OSM   Fieldwork is  helpful, it is not required to contribute to OSM   Fieldwork. You can  start by reviewing the documentation, exploring   the codebase, and contributing to issues labeled as good first issue.</p> <p>Q: How can I get help or support for OSM Fieldwork ?</p> <p>A: If you need help or support with XLSForms, you can reach out to the   ODK community on the ODK Forum. For   questions on OSM Fieldwork you can open an issue on the OSM   Fieldwork repository.</p> <p>Q: What are the benefits of contributing to OSM Fieldwork?</p> <p>A: Contributing to OSM Fieldwork allows you to help improve a widely used tools for data collection.</p> <p>Q: What is the license for OSM Fieldwork ?</p> <p>A: OSM Fieldwork is AGPLv3, because it encourages us to all work together. The XLSForms themselves are under the CC 4.0</p> <p>Q: How can I test my changes to OSM Fieldwork ?</p> <p>A: OSM Fieldwork has a suite of automated tests that you can run to ensure that your changes do not introduce new bugs or break existing functionality. You can run the tests locally on your computer using the command-line interface or by setting up a continuous integration environment on a platform like Travis CI.</p> <p>Q: Facing addititional problems?</p> <p>A: Visit Troubleshooting.</p>"},{"location":"about/Troubleshooting/","title":"Troubleshooting","text":""},{"location":"about/Troubleshooting/#unable-to-connect-to-the-odkcentral-server-over-http-ie-insecure","title":"Unable to connect to the ODKCentral server over http (i.e. insecure)","text":"<p>By default, ODKCentral API connections are verified with SSL certificates. However, sometimes, users may encounter issues connecting to ODK Central with self-signed certificates. This is common for developers if running ODK Central in a local subnet without a public domain name.</p> <p>Here are some steps to troubleshoot and resolve the issue:</p> <ul> <li>Add the certificate to your system trusted certificate store.</li> </ul> <p>If you are using a self-signed certificate, make sure to add it to your system's trusted certificate store. For Ubuntu/Debian users, follow the steps below: </p> <pre><code>In a terminal:\nsudo apt update &amp;&amp; sudo apt install ca-certificates\nsudo cp cert.crt /usr/local/share/ca-certificates/\nsudo update-ca-certificates\n</code></pre> <p>If running OSM Fieldwork within the Field Mapping Tasking Manager, this is handled for you. </p> <p>Q: Can I disable SSL verification (not recommended)</p> <p>A:  If you have tried the above step and still cannot connect to     ODK Central, you can disable SSL verification for the     certificate. However, this is not recommended as it will connect     to ODK Central insecurely. To do this, add the environment     variable ODK_CENTRAL_SECURE=False to your system.</p>"},{"location":"about/Troubleshooting/#additional-troubleshooting-steps","title":"Additional Troubleshooting Steps","text":"<p>If you are still unable to connect to the ODKCentral server over HTTP: </p> <ul> <li> <p>Verify that the ODK Central API URL is correct</p> <p>Make sure that you have entered the correct ODK Central API URL in your OSM Fieldwork configuration file. You can check the URL by logging into ODK Central and navigating to the \"Site Configuration\" page.</p> </li> <li> <p>Check that the ODK Central server is running</p> <p>Make sure that the ODK Central server is running and accessible. You can check the server status by navigating to the ODK Central API URL in your web browser. </p> </li> <li> <p>Check that the ODK Central server is reachable from your network</p> <p>Make sure that your network is not blocking the connection to the ODK Central server. You can try pinging the server from your computer to see if there is a network issue. </p> </li> <li> <p>Check that your firewall is not blocking the connection</p> <p>Make sure that your firewall is not blocking the connection to the ODK Central server. You can try temporarily disabling your firewall to see if this resolves the issue. </p> </li> <li> <p>Check the ODK Central server logs</p> <p>Check the ODK Central server logs to see if there are any error messages related to the connection. This can help identify the root cause of the issue. </p> </li> <li> <p>Try using a different web browser</p> <p>If you are having trouble connecting to ODK Central through a web browser, try using a different browser to see if the issue persists. It is possible that the issue is related to the browser or its settings. </p> </li> <li> <p>Update OSM Fieldwork and ODK Central to the latest version</p> <p>Make sure that you are using the latest version of OSM Fieldwork and ODK Central. Check the OSM Fieldwork and ODK Central release notes to see if any updates address the issue you are experiencing. </p> </li> </ul>"},{"location":"about/Version-Control/","title":"Version Control","text":""},{"location":"about/Version-Control/#conventional-commits","title":"Conventional Commits","text":"<p>A specification for adding human and machine readable meaning to commit messages.</p> <p>Format: [optional scope]:  <p>Example <code>feat: allow provided config object to extend other configs</code> Example <code>fix: fixed the bug in issue #123</code></p> <p>Advantage: Automated SemVer version management (major.minor.patch), and automated changelogs.</p>"},{"location":"about/Version-Control/#commitizen-cli","title":"Commitizen CLI","text":"<p>Commitizen is a Python tool to help with creating conventional commits and automating version control.</p>"},{"location":"about/Version-Control/#install","title":"Install","text":"<p><code>pip install commitizen</code></p>"},{"location":"about/Version-Control/#commiting-code","title":"Commiting Code","text":"<ul> <li>Instead of <code>git commit</code> use <code>cz commit</code> and follow the prompts.</li> <li>You can select the type of commit, plus additional metadata.</li> </ul>"},{"location":"about/Version-Control/#bumping-a-version","title":"Bumping a Version","text":"<ul> <li> <p>When you decide it is time to create a new version:</p> </li> <li> <p>Create a new branch</p> </li> </ul> <p><code>git checkout -b bump/new_release</code></p> <ol> <li>Bump the version and push</li> </ol> <pre><code>pip install commitizen # (if not installed)\n\ncz bump --check-consistency --changelog\n\ngit push\n</code></pre> <p>This will: - Update the SemVer version number in locations specific in <code>pyproject.toml</code>, throughout the codebase.   - If a <code>feat</code> commit is included, the version is bumped by a minor increment (0.x.0), if only <code>fix</code> is included a patch will be used (0.0.x). - Automatically update CHANGELOG.md with all changes since the last version. - Create a tag matching the version number.</p> <p>Note: in a repo where you have direct push access, you would simply update on main and push. As we are using Git-Flow, a PR is necessary.</p>"},{"location":"about/Version-Control/#creating-releases","title":"Creating Releases","text":"<ol> <li>Update the version throughout the code (Bumping a Version).</li> <li>Go to the Releases page.</li> <li>Click <code>Draft a new release</code>.</li> <li>Click <code>Choose a tag</code>, then input the current version number and press enter (this will automatically create a matching tag for your release).</li> <li>Set the <code>Release title</code> to v<code>x.x.x</code>, replacing with your version number.</li> <li>Add a description if possible, then release.</li> </ol> <p>This should trigger the PyPi publishing workflow, and your version will be available on PyPi.</p>"},{"location":"about/_Sidebar/","title":"Home","text":"<p>About</p> <p>Code of Conduct</p> <p>Contribution</p> <p>User Manual</p> <p>FAQ</p> <p>Verion Control</p> <p>Troubleshooting</p>"},{"location":"about/_Sidebar/#programs","title":"Programs","text":"<p>Configuration</p> <p>Base Mapper</p> <p>CSVDump</p> <p>ODK Client</p> <p>ODK Merge</p>"},{"location":"about/_Sidebar/#modules-utilities","title":"Modules &amp; Utilities","text":"<p>Program Summaries</p> <p>OSM XML Output</p> <p>YAML Config File</p>"},{"location":"about/_Sidebar/#technical-deep-dives","title":"Technical Deep Dives","text":"<p>Conflation</p> <p>External Data</p> <p>XLS Forms</p>"},{"location":"about/basemapper/","title":"Basemapper.py","text":"<p>Basemapper is a program that creates basemaps for mobile apps in the mbtiles and sqlitedb formats. These formats are commonly used by mobile mapping applications like Osmand and ODK Collect. There are two primary formats:</p> <ul> <li>mbtiles, supported by many apps.</li> <li>sqlitedb, supported only by Osmand</li> </ul> <p>Both of these use formats use underlying sqlite3, with similar database  schemas. The schema are a simple XYZ that stores a png or jpeg image. When the entire planet is chopped into squares, there is a relation between which map tile contains the GPS coordinates you want. Small zoom levels cover a large area, higher zoom levels a smaller area.</p> <p>Basemapper does not store anything in memory, all processing is done as a stream so large areas can be downloaded. Time to go buy a really large hard drive. You can also use this map tile cache for any program that supports a TMS data source like JOSM. Luckily once downloaded,  you don't have to update the map tile cache very often, but it's also easy to do so when you need to. When I expect to be working offline, I commonly download a larger area, and then in the field produce the smaller files.</p> <p>Basemapper. downloads map tiles to a cache and uses them to generate the output files. It does not perform data conversion. The resulting output can be used for visualizing geographic data and analyzing survey responses in a spatial context. The script provides various command-line options for customizing the output, such as setting the zoom levels, boundary, tile cache, output file name, and more.</p>"},{"location":"about/basemapper/#database-schemas","title":"Database Schemas","text":"<p>Mbtiles are used by multiple mobile apps, but our usage is primarly for ODK Collect. Imagery basemaps are very useful for two reasons. One, the map data may be lacking, so the imagery helps one to naviagte. For ODK Collect the other advantage is you can select the location based on where the building is, instead of were you are standing. Mbtiles are pretty straight forward.</p> <p>The sqlitedb schema used by Osmand looks the same at first, but has one big difference. In this schema it tops out at zoom level 16, so instead of incrementing, it decrements the zoom level. This obscure detail took me a while to figure out, it isn't documented anywhere.</p>"},{"location":"about/basemapper/#mbtiles","title":"mbtiles","text":"<pre><code>CREATE TABLE tiles (zoom_level integer, tile_column integer, tile_row integer, tile_data blob);\nCREATE INDEX tiles_idx on tiles (zoom_level, tile_column, tile_row);\nCREATE TABLE metadata (name text, value text);\nCREATE UNIQUE INDEX metadata_idx  ON metadata (name);\n</code></pre>"},{"location":"about/basemapper/#sqlitedb","title":"sqlitedb","text":"<pre><code>CREATE TABLE tiles (x int, y int, z int, s int, image blob, PRIMARY KEY (x,y,z,s));\nCREATE INDEX IND on tiles (x,y,z,s);\nCREATE TABLE info (maxzoom Int, minzoom Int);\nCREATE TABLE android_metadata (en_US);\n</code></pre>"},{"location":"about/basemapper/#usage","title":"Usage","text":"<p>The basemapper.py script is run from the command line when running standalone, or the class can be imported into python programs. The Field Mapping Tasking Manager uses this as part of a (FastAPI])https://fastapi.tiangolo.com/) backend for the website.</p> <p>The first time you run basemapper.py, it'll start downloading map tiles, which may take a long time. Often the upstream source is slow. It is not unusual for downloading tiles, especially at higher zoom levels may tak an entire day. Once tiles are download, producing the outout tiles is quick as then it's just packaging. In areas where I work frequentely, I usually download a large area even if it takes a week or more so it's available when I need it. On my laptop I actually have a map tile cache for the entire state of Colorado, as well as many large areas of Nepal, Turkey, Kenya, Uganda, and Tanzania.</p>"},{"location":"about/basemapper/#options","title":"Options","text":"<p>The basic syntax is as follows:</p> <ul> <li>-input_file, --This is a required positional argument that specifies the path to the input ODK form.</li> <li>-h, --help show this help message and exit</li> <li>-v, --verbose verbose output</li> <li>-b BOUNDARY, --boundary BOUNDARY - The boundary for the area you want, as BBOX string or geojson file.</li> <li>-z ZOOMS, --zooms ZOOMS - The Zoom levels</li> <li>-o OUTFILE, --outfile - OUTFILE Output file name</li> <li>-d OUTDIR, --outdir OUTDIR -Output directory name for tile cache</li> <li>-s {ersi,bing,topo,google,oam}, --source {ersi,bing,topo,google,oam} - Imagery source</li> </ul> <p>The suffix of the output file is either mbtiles or sqlitedb, which is used to select the output format. The boundary file, if specified, must be in GeoJson format. If in BBOX string format, it must be comma separated: \"minX,minY,maxX,maxY\".</p>"},{"location":"about/basemapper/#imagery-sources","title":"Imagery Sources","text":"<ul> <li>ESRI - Environmental Systems Research Institute</li> <li>Bing - Microsoft Bing imagery </li> <li>Topo - USGS topographical maps (US only)</li> <li>OAM - OpenAerialMap</li> </ul> <p>The default output directory is /var/www/html. The actual subdirectory is the soiurce name with tiles appended, so for example /var/www/html/oamtiles. Putting the map tiles into webroot lets JOSM or QGIS use them when working offline.</p>"},{"location":"about/basemapper/#examples","title":"Examples","text":""},{"location":"about/basemapper/#example-1","title":"Example 1:","text":"<p>Generate a basemap for Osmand using ERSI imagery, for an area  specified by a geojson bounding box, and supporting zoom levels 12 through 19.</p> <pre><code>[path]/basemapper.py -z 12-19 -b test.geojson -o test.sqlitedb -s esri\n</code></pre>"},{"location":"about/basemapper/#example-2","title":"Example 2:","text":"<p>As above, but mbtiles format, and Bing imagery source. The <code>-v</code> option enables verbose output, which will show more details about the download and processing progress. Also only download a single zoon level.</p> <pre><code>[path]/basemapper.py -v -z 16 -b test.geojson -o test.mbtiles -s bing\n</code></pre>"},{"location":"about/configuring/","title":"Configuring the Data Conversion","text":"<p>Osm_Fieldwork uses a YAML-based configuration file that controls the conversion process. While ideally, the tags in the XForm are a match for OSM tags, some survey questions generate very different primary tags. All of the strings in this file are lowercase, as when processing the CSV file, everything is forced to be lowercase.</p> <p>YAML is a simple syntax, and most of the config options are simply lists. For example:</p> <pre><code># All of the data that goes in a different non-OSM file\nprivate:\n  - income\n  - age\n  - gender\n</code></pre> <p>There are 3 sections in the config file, ignore, convert, and private. Anything in the ignore section gets left out of all data processing and output files. Anything in the private section is kept out of the OXM output file, but included in a separate GeoJson formatted file. That file contains all the data from whoever is organizing this mapping campaign. There are often data items like gender that don't belong in OSM, but that information is useful to the organizers. Anything in the convert section is the real control of the conversion process.</p>"},{"location":"about/configuring/#here-is-an-example-of-a-configuration-file-with-explanations-of","title":"Here is an example of a configuration file with explanations of","text":"<p>its different sections and options expained in detail:</p> <pre><code>#ignore section\nignore:\n  - respondent_name\n  - survey_date\n\n#private section\nprivate:\n  - age\n  - gender\n\n#convert section\nconvert:\n  #example of a simple conversion\n  - waterpoint:\n    - well: man_made=water_well\n    - natural: natural=water\n  #example of a conversion with multiple OSM tags\n  - power:\n    - solar: generator::source=solar,power=generator\n    - wind: generator::source=wind,power=generator\n    - hydro: generator::source=hydro,power=generator\n    - geothermal: generator::source=geothermal,power=generator\n    - grid: generator::source=electricity_network,power=generator\n</code></pre> <p>The configuration file has three sections: <code>ignore</code>, <code>private</code>, and <code>convert</code>.</p> <p>The <code>ignore</code> section lists the names of data fields that should be ignored during the conversion process. These fields will not be included in any output files.</p> <p>The <code>private</code> section lists the names of data fields that are considered private and should not be included in the OSM output file. However, they will be included in a separate GeoJson formatted file. This file contains all the data from whoever is organizing the mapping campaign. An example of private data is gender, which is useful to the organizers but not relevant to OSM.</p> <p>The <code>convert</code> section is the real control of the conversion process. It lists the survey questions and their corresponding OSM tags and values. In this section, each survey question is represented by a tag name, and each answer to the survey question is represented by a value. If the answer matches the value, it returns both the tag and the value for OSM. An equal sign is used to delimit them.</p> <p>For example, in the configuration file above, the survey question about waterpoints has two possible answers: \"well\" and \"natural\". If the answer is \"well\", the corresponding OSM tag and value is \"man_made=water_well\". If the answer is \"natural\", the corresponding OSM tag and value is \"natural=water\".</p> <p>Another example in the same configuration file is the survey question about power sources. This survey question has five possible answers: \"solar\", \"wind\", \"hydro\", \"geothermal\", and \"grid\". Each answer corresponds to multiple OSM tags and values, which are separated by commas.</p> <p>For example, if the answer is \"solar\", the corresponding OSM tags and values are \"generator::source=solar\" and \"power=generator\". The double colon is used to represent a hierarchy in the OSM tags. In this example, the generator source is solar, and the power source is a generator.</p> <p>Both ODK and OSM use a tag/value pair. In OSM, the tags and values are documented, and the mapping community prefers people use the commonly accepted values. In ODK, the tags and values can be anything the developer of the XLSForm chooses. Depending on the answer to the survey question, that may be converted to a variety of OSM tags and values.</p> <p>For this example, the value used in the name column of the XLSForm survey sheet is waterpoint. It has several values listed underneath. Each of those is for the answer given to the waterpoint survey question. If the answer matches the value, it returns both the tag and the value for OSM. An equal sign is used to deliminate them.</p> <pre><code>- waterpoint:\n  - well: man_made=water_well\n  - natural: natural=water\n</code></pre> <p>Some features have multiple OSM tags for a single survey question answer. To handle this case, all entries are deliminated by a comma.</p> <pre><code>- power:\n  - solar: generator::source=solar,power=generator\n  - wind: generator::source=wind,power=generator\n  - hydro: generator::source=hydro,power=generator\n  - geothermal: generator::source=geothermal,power=generator\n  - grid: generator::source=electricity_network,power=generator\n</code></pre> <p>Overall, the configuration file is a powerful tool for customizing the conversion of ODK data into OSM tags and values. By carefully defining the <code>ignore</code>, <code>private</code>, and <code>convert</code> sections, you can control the output of the conversion process and ensure that it meets your needs.</p> <p>Here's a simple chart of the conversion Data Flow.</p>"},{"location":"about/conflation/","title":"Conflating With OpenStreetMap","text":"<p>Now that the data collected using ODK Collect has been converted to OSM XML, it needs to be conflated against the existing OpenStreetMap(OSM) data before validation by a human being. Due to the wonderful flexibility of the OpenStreetMap(OSM) data schema, this can be difficult to fully automate. At best it can assist the human mapper by identifying probable duplicates, and other conflation issues. Rather than delete the possible duplicates, instead a tag is added so the mapper can find them easily and decide.</p> <p>Conflation algorythms are not very elegant, they are usually slow and brute force. But they also save the mapper time doing this completely manually.</p> <p>This project's conflation software can use either a local postgres database, or a GeoJson file produced by the make_data_extracts program. This program is also used by FMTM, so you can use those as well. Obviously using postgres locally is much faster, especially for large areas.</p>"},{"location":"about/conflation/#setting-up-postgres","title":"Setting Up Postgres","text":"<p>For raw OSM data, the existing country data is downloaded from GeoFabrik, and imported using a modified schema for osm2pgsql.</p> <pre><code>osm2pgsql --create -d nepal --extra-attributes --output=flex --style raw.lua nepal-latest-internal.osm.pbf\n</code></pre> <p>The raw.lua script is available here. It's part of the Underpass project. It uses a more compressed and efficient data schema designed for data analysis. Once the data is imported, do this to improve query performance.</p> <pre><code>cluster ways_poly using ways_poly_geom_idx;\ncreate index on ways_poly using gin(tags);\n</code></pre> <p>The existing OSM database schema stores some tags in columns, and other tags in a hstore column. Much of this is historical. But this also makes it very complicated to query the database, as you need to know what is a column, and what is in the hstore column. The raw.lua schema is much more compact, as everything is in a single column.</p>"},{"location":"about/conflation/#using-postgres","title":"Using Postgres","text":"<p>If you use the odk_merge program, you don't have to deal with accessing the database directly, but here's how if you want to.</p> <p>This would find all of the tags for a hotel:</p> <pre><code>SELECT osm_id, tags FROM nodes WHERE tags-&gt;&gt;'amenity'='hotel'\n</code></pre> <p>If you want to get more fancy, you can also use the geometry in the query. From python we setup a few values for the query, and note the ::geometry suffix, which uses meters instead of units. Meters are easier to work with than units of the planet's circumferance.</p> <p>self.tolerance = 2 wkt.wkt = \"Point\", \"coordinates\": [-107.911957, 40.037573] value = 'Meeker Hotel'</p> <p>query = f\"SELECT osm_id,tags,version,ST_AsText(ST_Centroid(geom)) FROM ways_POLY WHERE ST_Distance(geom::geography, ST_GeogFromText(\\'SRID=4326;{wkt.wkt}\\')) &lt; {self.tolerance} AND levenshtein(tags-&gt;&gt;'name', {value}) &lt;= 1\"</p> <p>This query finds any building polygon with 2 meters where the name matches. The levenstein function does a fuzzy string match, since minor differences in the name can still be a match. Minor typos in the ODK collected data or OSM often have minor typos.</p>"},{"location":"about/conflation/#using-a-geojson-file","title":"Using a GeoJson File","text":"<p>Using a data file also works the same way, only you can't really query the data file the same way. Instead the entire data file is loaded into a data structure so it can be queried by looping through all the data. While not very efficient, it works well.</p>"},{"location":"about/conflation/#conflating-the-data","title":"Conflating The Data","text":"<p>All data collected using Collect is a node, but we also want to check both nodes and ways. Many amenities in OSM are only a node, since adding data with a mobile app, POIs is all they support. Any data added by JOSM or the iD editors is often a polygon. Many buildings have been added to OSM using the HOT Tasking Manager, and were traced from satellite imagery.</p> <p>Buildings traced from imagery have only a single tag, which is building=yes. When field mapping, we now know that building is a resturant, a medical clinic, or a residence. Since OSM guidelines prefer the tags fo on the building polygon, and not be a separate POI within the building. If there are multiple businesses in the same building polygon, then they stay as a POI in the building.</p>"},{"location":"about/conflation/#conflating-with-postgres","title":"Conflating With Postgres","text":"<p>Since the database has 2 tables, one for nodes and the other for polygons, we have to query both. A possible duplicate is one that is within the desired distance and has a match in one of the tags and values. Names are fuzzy matched to handle minor spelling differences.</p> <p>The nodes table is queried first. If no possible duplicates are found, then the ways table is queried next. The query just looks for any nearby POI that has a match between any of the tags. Currently the distance is set to 2 meters. Often the GPS coordinates from Collect are where you are standing, usualy in front of the building. This distance threshold is configurable, but if it's too large, you get many false positives. As all mobile mapping apps only add a POI for an amenity, it's common it's in the nodes table.</p> <p>If nothing is found in the nodes table, then we check the polygons the same way, distance and a tag match. Often people working on a desktop or laptop may add more tags to an existing feature, and properly have all the tags be in the building way, and not a POI within the building. If there are miltiple small businesses in the same building, then each remains a POI within the building polygon.</p> <p>If a possible duplicate is found, the tags from the collected data and the tags from OSM are merged together. In the case of the name tag, the existing name is converted to an old_name tags, and the collected name value is used for the *name tag.</p>"},{"location":"about/conflation/#conflating-with-a-geojson-file","title":"Conflating with a GeoJson File","text":"<p>Since GeoJson supports multiple geometry types, unlike postgres, there is only one set of data to compare against. The same process as used for postgres is used for the data file, the only difference being the data file is loaded into a data structure, and then has to loop through all the existing features. This is slower than using postgres, but works the same. One advantage is this can use he data extract from FMTM, and not require the mapper to have a postgres database.</p>"},{"location":"about/conflation/#string-matching","title":"String Matching","text":"<p>There are more spelling mistakes, weird capitalization, embedded quotes, etc... in the values for the name tag than I can count. This makes matching on the name somewhat complicated even when using fuzzy string matching. Typing in names on one's smartphone also can add typos or do auto-correction. And of course those mistakes may also already be in OSM, and the feature you collected may be the correct one.</p> <p>For a potential match, the old value is placed in a old_name tag, in addition to the the fixme tag used to flag a possible duplicate. This enables the validator to decide and fix any minor differences in the value. This mostly only applies to the name tag, as most other tags have a more formalized value.</p> <p>When an amenity has changed names, for example when a restaurant gets new owners, this won't likely be caught as a duplicate unless the amenity tag values match.</p>"},{"location":"about/conflation/#validating-the-results","title":"Validating The Results","text":"<p>Conflation does not generate perfect results. It's necessary to have a validator go through the reults and decide. The output file from conflation does not remove anything from the collected data. Instead it adds custom tags on what it finds. This way the validator can search for those tags when getting started, and delete the duplicate and validate the tag merging.</p> <p>The primary tag added is a fixme tag for possible duplicates. If there is more than a difference in the string values used for the name tag, the existing tag is renamed to be old_name. While this is not an actual OSM tag, the alt_name tag is currrently used to avoid conflicts. It's up to the validator to decide what the apppropriate value is.</p> <p>I often notice when collecting data in the field on my smartphone, typos are common. Missing capitalization on names or sometimes the wrong character is common.</p> <p>Here's a simple chart of the conversion Data Flow.</p>"},{"location":"about/convert/","title":"Convert.py","text":"<p>The convert.py module is part of the osm_fieldwork package and provides functionality for converting ODK forms to OSM XML using a YAML configuration file.</p> <p>Even if an XLSForm is carefully designed to have a one to one match between ODK and OSM, this is not always possible, as not all survey questions are for OSM.</p>"},{"location":"about/convert/#the-config-file-sections","title":"The Config File Sections","text":"<p>There are several sections the config file. The default one is called xforms.yaml, and is included in the sources and the python package. It is possible to use a different config file.</p>"},{"location":"about/convert/#convert","title":"convert","text":"<p>This section supports one to one conversion of tags, as well as one to many. This example shows all poossible conversion types. The simple ones like altitude just change the tag, and the value is used unchanged. A more complicated conversion is changing the value in addition to the tag. Anything with an equals sign is split into the appropriate tag and value for OSM. The final one is where a singe survey question creates multiple tahg and value pairs, deliminated by a comma. Each of the pairs is handled as a separate tag and value in OSM.</p> <pre><code>convert:\n    - latitude: lat\n    - longitude: lon\n    - altitude: ele\n    - cemetery_services:\n        - cemetery: amenity=grave_yard\n        - cremation: amenity=crematorium\n    - amenity:\n        - coffee: amenity=cafe,cuisine=coffee_shop\n...\n</code></pre>"},{"location":"about/convert/#private","title":"private","text":"<p>Not all collected data is suitable for OSM. This may include data that has no equivalant tag in OSM, or personal data. </p> <pre><code>private:\n    - income\n    - age\n    - gender\n    - education\n</code></pre>"},{"location":"about/convert/#ignore","title":"ignore","text":"<p>ODK supports many tags useful only internally. These go into the ignore section of the config file. Any tag in this section gets removed from from all output files. An example would be this:</p> <pre><code>ignore:\n    - attachmentsexpected\n    - attachmentspresent\n    - reviewstate\n    - edits\n    - gps_type\n    - accuracy\n    - deviceid\n...\n</code></pre>"},{"location":"about/convert/#multiple","title":"multiple","text":"<p>Not all survey questions have a single answer. Anything using select_multiple may have more than one value. As the default assumes one answer per question, this specifies the questions with multiple answers since they have to be processed seperately. The normal conversion process is applied to these too.</p> <pre><code>multiple:\n    - healthcare\n    - amenity_type\n    - specialty\n</code></pre>"},{"location":"about/externaldata/","title":"Dealing with External Data in ODK","text":""},{"location":"about/externaldata/#external-datasets","title":"External Datasets","text":"<p>ODK Collect has recently gained the ability to load an external data file in GeoJson format of existing data. It's now possible to select existing data and then import its values into the XForm as default values. This lets the mapper use the XForm to change the existing data, or add to it. Any changes will need to be conflated later, that'll be another document.</p> <p>Why do I want to use ODK Collect to edit map data? Much of what is currently in OpenStreetMap is lacking metadata, or the data has changed, like when a restaurant changes owners and gets a new name. Also most all remote mapping using satellite imagery lacks tags beyond building=yes. When we are doing a ground data collection project, we want to add useful tags like the building material, or whether it's a cafe or a hospital.</p> <p>Old imports also bring in problems, for example the infamous TIGER import. Mappers have been cleaning that mess in North America up for over a decade. But an old import may have a weird value for an OSM tag, and it's usually better to update to a more community approved data model. The beauty and the curse of OSM data is its wonderful flexibility. People do invent new tags for a specific mapping campaign or import that doesn't get reviewed. Sometimes values have embedded quote marks or weird capitalization, and other strange formatting worth correcting.</p>"},{"location":"about/externaldata/#creating-the-geojson-file","title":"Creating the GeoJson file","text":"<p>When working with OSM data, there are multiple sources to obtain the required data. One option is to download a daily database dump from GeoFabrik, which can be used as a flat file or imported into a database. The Humanitarian OpenStreetMap Team(HOT) maintains two projects that can also be used for data extracts. The primary one has a web based user interface, and is called the HOT Export Tool. The other option runs in a terminal and is part of OSM Fieldwork project, and is also used as part of the Field Mapping Tasking Manager backend. That program is available here. Alternatively, Overpass Turbo can also be used to query the data but you have to understand the Overpass query syntax.</p> <p>It's important to keep in mind that there is a translation between the column names obtained from querying the data and how ODK Collect views it. There is also a translation from ODK to OSM, and it's important to ensure that all translations work together seamlessly for a smooth data flow. To maintain clarity, it's best to keep all tags and values as similar as possible, with unique names. When using ogr2ogr for data extraction from a Postgres database, there is more control than when using Overpass, and larger datasets can be processed. You can clean up all the tag names later if you add a custom config file for the conversion.</p> <p>As the GeoJson file gets turned into an XPATH components when converted to an XForm, the actual filename without the suffix becomes a node in the XPATH, so you can't have a survey question using the same name as the filename. It is prefered to have the name using the actual OSM tag instead of the file. If you get this error, you need to rename the GeoJson file.</p> <pre><code>Duplicate type: 'choice', Duplicate URI: 'None', Duplicate context: 'survey'.\n</code></pre>"},{"location":"about/externaldata/#naming-conflicts","title":"Naming Conflicts","text":"<p>If you do want to use an OSM tag name in a calculate field, a technique for maintaining consistency is to prefix an x to the start of each column name, so healthcare becomes xhealthcare. Then, in the XLSForm, healthcare can be used for the instance, and xhealthcare can be used for the value in the calculation column in the survey sheet. The name column in the survey sheet can then be just healthcare, which will translate directly into its OSM tag equivalent. For this example note that the GeoJson file must not be named healthcare.geojson, because it'll conflict with __healthcare_. You can also avoid this by having the calculation in the same row as the survey question and avoiding the variable. If you do that, add a trigger for the geojson file, and it'll populate the default value for the question.</p> <p>It's possible to support almost any value using a text type in the XLSForm, but it's better to have an approved value for tag validation and completeness. If using a data model, the list of choices for a tag is defined, and anything outside of that will cause an error. Therefore, it's important to adhere to validated data models to avoid introducing errors or inconsistencies into the dataset. If the SQL query returns columns that aren't compatible with the XLSForm, XPATH errors will occur in ODK Collect. </p> <p>Something else to consider is the frequency of the tags and values. Since almost anything can be added to OSM, there are a lot of obscure ones. It's strongly suggested to use more common tags and values. A resource for this is the Taginfo website, which lists everything every used in OSM. There are two columns of interest, one is whether the tag is on the OSM wiki, and the other is how many times that tag is used. I try to use tags that are on the wiki whenever possible, or at least have high frequency counts.</p>"},{"location":"about/externaldata/#data-filtering","title":"Data filtering","text":"<p>For the external file to load properly in ODK Collect, any tags and values in the data extract must be in the choices sheet. Otherwise ODK Collect will fail to launch. The OSM Fieldwork project has a utility program which can be imported into other python programs that scans the XLSForm choices sheet, and removes anything in the data extract that isn't supported as a choice.</p>"},{"location":"about/externaldata/#debugging-select_from-file-with-geojson","title":"Debugging select_from file with GeoJson","text":"<p>Debugging complex interactions between the XLSForm, external data files, and ODK Collect can be a challenging task. Here are a few tricks to help debug what is going on. I strongly suggest developing your XLSForm initially without the data extracts. That way you can use Enketo, which you can access using the Preview button in ODK Central. Get all the survey questions, grouping, conditional, etc... so it's easy to test with Enketo. Enketo doesn't work with the GeoJson based data extract. Then add the data extract, and the calculation column entries to use the OSM data to set the survey question default value.</p>"},{"location":"about/externaldata/#disable-the-map-appearance","title":"Disable the map appearance","text":"<p>When working with external data, the map value in the appearance column of the survey sheet is often used. However, this can slow down the debugging process. To make it more efficient, you can turn off the map values and use the select menu instead. That works especially well  if you have a small data file for testing, because then it's easy to cycle between them.</p> <p>To use the placement map, here's an example.</p> type name label appearance select_one_from_file camp_sites.geojson existing Existing Campsites map <p>And an example where the values in the data file are an inline select menu instead.</p> type name label appearance select_one_from_file camp_sites.geojson existing Existing Campsites minimal"},{"location":"about/externaldata/#display-calculated-values","title":"Display calculated values","text":"<p>Often the bug you are trying to find is obscure, and you may not see any of the data file values being propagated into ODK Collect, even if it was working previously. In such cases, you can add a text survey question to display any of the values. Here's an example:</p> type name label calculation trigger calculate xid OSM ID instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/id calculate xlabel Get the label instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/title calculate xref Reference number instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/ref calculate xlocation Location instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/geometry calculate xtourism camping type instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/tourism calculate xleisure leisure type instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/leisure text debug1 Leisure ${xleisure} ${existing} text debug2 OSM ID ${xid} ${existing} text debug3 Ref number ${xref} ${existing} text debug4 Tourism ${xtourism} ${existing} text name Business Name ${xlabel} ${existing} <p>For a value that is only used once to set the default value in Collect, you can also reference it in the same row. This saves potential naming conflicts, although is why I use an x prefix for gobal values.</p> type name label calculation trigger text name Business Name instance(\u201ccamp_sites\u201d)/root/item[id=${existing}]/name ${existing}"},{"location":"about/externaldata/#error-dialog","title":"Error Dialog","text":"<p>Assuming xls2xform is happy, sometimes you get this error message in ODK Collect when switching screens. You'll see this when you have a value in your data file for a select_one survey question, but that value is not in the list of values in the choices sheet for that tag. In this example, there is no doctor value in the healthcare selection in the choices sheet. If you use the data filtering utility program mentioned above, you'll never see this error.</p> <p></p>"},{"location":"about/json2osm/","title":"json2osm.py","text":"<p>convert JSON from ODK Central to OSM XML</p> <pre><code>usage: json2osm [-h] [-v] [-y YAML] [-x XLSFILE] -i INFILE\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --verbose         verbose output\n  -y YAML, --yaml YAML  Alternate YAML file\n  -x XLSFILE, --xlsfile XLSFILE\n                        Source XLSFile\n  -i INFILE, --infile INFILE\n                        The input file downloaded from ODK Central\n</code></pre>"},{"location":"about/make_data_extract/","title":"make_data_extract","text":""},{"location":"about/make_data_extract/#make_data_extractpy","title":"make_data_extract.py","text":"<p>The <code>make_data_extract.py</code> program is used to extract OpenStreetMap (OSM) data for use with the <code>select_one_from_file</code> function in ODK Collect. This function allows users to select from a list of options generated from an external file. The <code>make_data_extract.py</code> program creates a data extract that can be used as an external file with the XLSForm. The data extract can be created using local Postgres database, or the remote Underpass database.</p> <p>To use the new <code>select_one_from_file</code> for editing existing OSM data you need to produce a data extract from OSM. This can be done several ways, but needed to be automated to be used for FMTM.</p> <pre><code>options:\n --help (-h)               show this help message and exit\n --verbose (-v)            verbose output\n --geojson (-g) GEOJSON    Name of the GeoJson output file\n --boundary (-b) BOUNDARY  Boundary polygon to limit the data size\n --category (-c) CATEGORY  Which category to extract\n --uri (-u) URI            Database URI\n --xlsfile (-x) XLSFILE    An XLSForm in the library\n --list (-l) List          List all XLSForms in the library\n</code></pre>"},{"location":"about/make_data_extract/#examples","title":"Examples","text":"<p>Make_data_extract uses a Postgres database to extract OSM data. By default, the program uses localhost as the database host. If you use underpass as the data base name, this will remotely access the Humanitarian OpenStreetMap Team(HOT) maintained OSM database that covers the entire planet, and is updated every minute. The name of the database can be specified using the *--uri_ option. The program extracts the buildings category of OSM data by default. The size of the extracted data can be limited using the --boundary option. The program outputs the data in GeoJSON format.</p> <p>For raw OSM data, the existing country data is downloaded from GeoFabrik, and imported using a modified schema for osm2pgsql. First create the database and install two postgres extensions:</p> <pre><code># createdb nigeria\npsql -d nigeria -c \"CREATE EXTENSION postgis\"\npsql -d nigeria -c \"CREATE EXTENSION hstore\"\n</code></pre> <p>And then import the OSM data.</p> <p>osm2pgsql --create -d nigeria --extra-attributes --output=flex --style raw.lua nigeria-latest-internal.osm.pbf</p> <p>The raw.lua script is available here. It's part of the Underpass project. It uses a more compressed and efficient data schema.</p>"},{"location":"about/make_data_extract/#example","title":"Example:","text":"<pre><code>./make_data_extract.py -u colorado --boundary mycounty.geojson -g mycounty_buildings.geojson\n</code></pre> <p>This example extracts the <code>buildings</code> category of OSM data from a Postgres database named <code>colorado</code>. The program limits the size of the extracted data to the boundary specified in the <code>mycounty.geojson</code> file. The program outputs the data in GeoJSON format to a file named <code>mycounty_buildings.geojson</code>.</p>"},{"location":"about/make_data_extract/#boundary","title":"Boundary:","text":"<p>The <code>--boundary</code> option can be used to specify a polygon boundary to limit the size of the extracted data. The boundary has to be in GeoJSON format, both multipolygons and polygons are supported.</p> <p>Example:</p> <pre><code>./make_data_extract.py -u foo@colorado --category healthcare --boundary mycounty.geojson -g mycounty_healthcare.geojson\n</code></pre> <p>This example extracts the <code>healthcare</code> category of OSM data from a Postgres database named <code>colorado</code> with e user foo. The program limits the size of the extracted data to the boundary specified in the <code>mycounty.geojson</code> file. The program outputs the data in GeoJSON format to a file named <code>mycounty_healtcare.geojson</code>.</p>"},{"location":"about/make_data_extract/#category","title":"Category:","text":"<p>The <code>--category</code> option can be used to specify which category of OSM data to extract. The program supports any category in the xlsform library</p>"},{"location":"about/make_data_extract/#example_1","title":"Example:","text":"<pre><code>./make_data_extract.py -u underpass --boundary mycounty.geojson --category amenities -g mycounty_amenities.geojson\n</code></pre> <p>This example uses Overpass Turbo to extract the <code>amenities</code> category of OSM data within the boundary specified in the <code>mycounty.geojson</code> file. The program outputs the data in GeoJSON format to a file named <code>mycounty_amenities.geojson</code>.</p>"},{"location":"about/make_data_extract/#output-file-format","title":"Output File Format:","text":"<p>The program outputs the extracted OSM data in GeoJSON format. The name of the output file can be specified using the <code>--geojson option</code>. If the option is not specified, the program uses the input file name with <code>_buildings.geojson</code> appended to it.</p> <pre><code>./make_data_extract.py -u colorado --boundary mycounty.geojson -g mycounty_buildings.geojson\n</code></pre>"},{"location":"about/make_data_extract/#file-formats","title":"File Formats","text":"<p>OpenDataKit has 3 file formats. The primary one is the source file, which is in XLSX format, and follows the XLSXForm specification. This file is edited using a spreadsheet program, and convert using the xls2xform program. That conversion products an ODK XML file. That file is used by ODK Collect to create the input forms for the mobile app. When using ODK Collect, the output file is another XML format, unique to ODK Collect. These are the data collection instances.</p> <p>The ODK server, ODK Central supports the downloading of XForms to the mobile app, and also supports downloading the collected data. The only output format is CSV.</p>"},{"location":"about/odk2csv/","title":"odk2csv","text":"<p>Convert ODK XML instance file to CSV format</p> <pre><code>usage: odk2csv [-h] [-v [VERBOSE]] -i INSTANCE\n\noptions:\n  -h, --help            show this help message and exit\n  -v [VERBOSE], --verbose [VERBOSE]\n                        verbose output\n  -i INSTANCE, --instance INSTANCE\n                        The instance file(s) from ODK Collect\n</code></pre>"},{"location":"about/odk2geojson/","title":"odk2geojson","text":"<p>Convert ODK XML instance file to GeoJson</p> <pre><code>usage: odk2geojson [-h] [-v [VERBOSE]] -i INSTANCE [-o OUTFILE]\n\noptions:\n  -h, --help            show this help message and exit\n  -v [VERBOSE], --verbose [VERBOSE]\n                        verbose output\n  -i INSTANCE, --instance INSTANCE\n                        The instance file(s) from ODK Collect\n  -o OUTFILE, --outfile OUTFILE\n                        The output file for JOSM\n</code></pre>"},{"location":"about/odk2osm/","title":"odk2osm","text":"<pre><code>Convert ODK XML instance file to OSM XML format\n\nusage: odk2osm [-h] [-v [VERBOSE]] -i INSTANCE\n\noptions:\n  -h, --help            show this help message and exit\n  -v [VERBOSE], --verbose [VERBOSE] verbose output\n  -i INSTANCE, --instance INSTANCE\n                        The instance file(s) from ODK Collect\n</code></pre>"},{"location":"about/odk_client/","title":"ODK Client","text":"<p>odk_client.py is a command line utility for  interacting with the ODK Central server. It exposes many of the REST API calls supported by the server and allows users to perform various tasks, such as uploading and downloading attachments and submissions.</p>"},{"location":"about/odk_client/#usage","title":"Usage","text":"<p><code>[-h] [-v] [-s {projects,users,delete}] [-p {forms,app-users,assignments,delete}] [-i ID] [-f FORM] [-u UUID]</code></p> <p><code>[-x {attachments,csv,submissions,upload,download,create,assignments,delete,publish}] [-a {create,delete,update,qrcode,access}] [-d DATA] [-t TIMESTAMP]</code></p> <p><code>[-b {qrcodes,update}]</code></p>"},{"location":"about/odk_client/#command-line-client-for-odk-central","title":"command line client for ODK Central","text":""},{"location":"about/odk_client/#options","title":"Options:","text":"<pre><code>  -h, --help            show this help message and exit\n  -v, --verbose         verbose output\n  -s {projects,users,delete}, --server {projects,users,delete}\n                        project operations\n  -p {forms,app-users,assignments,delete}, --project {forms,app-users,assignments,delete}\n                        project operations\n  -i ID, --id ID        Project ID number\n  -f FORM, --form FORM  XForm name\n  -u UUID, --uuid UUID  Submission UUID, needed to download the data\n  -x {attachments,csv,submissions,upload,download,create,assignments,delete,publish}, --xform {attachments,csv,submissions,upload,download,create,assignments,delete,publish}\n                        XForm ID for operations with data files\n  -a {create,delete,update,qrcode,access}, --appuser {create,delete,update,qrcode,access}\n                        App-User operations\n  -d DATA, --data DATA  Data files for upload or download\n  -t TIMESTAMP, --timestamp TIMESTAMP\n                        Timestamp for submissions\n  -b {qrcodes,update}, --bulk {qrcodes,update}\n                        Bulk operations\n</code></pre>"},{"location":"about/odk_client/#server-requests","title":"Server requests","text":"<p>Server requests allow users to access global data about projects and users. </p>"},{"location":"about/odk_client/#usage_1","title":"Usage","text":"<p>The following server-specific commands are supported by ODK Client:</p> <ul> <li><code>--server projects</code></li> </ul> <p>This command returns a list of project IDs and their corresponding project names.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --server projects\n</code></pre> <ul> <li><code>--server users</code></li> </ul> <p>This command returns a list of user IDs and their corresponding usernames.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --server users\n</code></pre>"},{"location":"about/odk_client/#project-requests","title":"Project Requests","text":"<p>Project requests allow users to access data for a specific project, such as XForms, attachments, and app users.  Projects contain all the Xforms and attachments for that project. To access the data for a project, it is necessary to supply the project ID. That can be retrieved using the above server command. In this example, 1 is used.</p>"},{"location":"about/odk_client/#usage_2","title":"Usage","text":"<p>The following are the project-specific commands supported by ODK Client:</p> <ul> <li><code>--id &lt;project_id&gt; --project forms</code></li> </ul> <p>This command returns a list of all the XForms contained in the specified project. Replace <code>\"&lt;project_id&gt;\"</code> with the actual ID of the project you want to retrieve the forms for.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --project forms\n</code></pre> <ul> <li><code>--id &lt;project_id&gt; --project app-users</code></li> </ul> <p>This command returns a list of all the app users who have access to the specified project. Replace <code>\"&lt;project_id&gt;\"</code> with the actual ID of the project you want to retrieve the list of app users for.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --project app-users\n</code></pre> <p>Note: Replace \"1\" with the actual ID of the project you want to access.</p>"},{"location":"about/odk_client/#xform-requests","title":"XForm Requests","text":"<p>XForm requests allow users to access data for a specific XForm within a project, such as attachments, submissions, and CSV data.  An XForm has several components. The primary one is the XForm description itself. In addition to that, there may be additional attachments, usually a CSV file of external data to be used by the XForm. If an XForm has been used to collect data, then it has submissions for that XForm. These can be downloaded as CSV files.</p> <p>To access the data for an XForm, it is necessary to supply the project ID and the XForm ID. The XForm ID can be retrieved using the above project command.</p>"},{"location":"about/odk_client/#usage_3","title":"Usage","text":"<p>The following are the XForm-specific commands supported by ODK Client:</p> <ul> <li><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform attachments</code></li> </ul> <p>This command returns a list of all the attachments for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, and \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to retrieve the attachments for.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --form 1 --xform attachments\n</code></pre> <ul> <li><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform download &lt;attachment_1&gt;,&lt;attachment_2&gt;,...</code></li> </ul> <p>This command downloads the specified attachments for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to download the attachments for, and \"<code>&lt;attachment_1&gt;</code>,<code>&lt;attachment_2&gt;</code>,<code>etc...</code>\" with the actual names of the attachments you want to download.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --form 1 --xform download file1.csv,file2.pdf\n</code></pre> <ul> <li><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform submissions</code></li> </ul> <p>This command returns a list of all the submissions for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, and \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to retrieve the submissions for.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --form 1 --xform submissions\n</code></pre> <ul> <li><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform csv</code></li> </ul> <p>This command returns the data for the submissions for the specified XForm in CSV format. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, and \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to retrieve the submission data for.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --form 1 --xform csv\n</code></pre> <ul> <li><code>--id &lt;project_id&gt; --form &lt;form_id&gt; --xform upload &lt;attachment_1&gt;,&lt;attachment_2&gt;,...</code></li> </ul> <p>This command uploads the specified attachments for the specified XForm. Replace \"<code>&lt;project_id&gt;</code>\" with the actual ID of the project that contains the XForm, \"<code>&lt;form_id&gt;</code>\" with the actual ID of the XForm you want to upload the attachments for, and \"<code>&lt;attachment_1&gt;,&lt;attachment_2&gt;,...</code>\" with the actual names of the attachments you want to upload.</p> <p>### Example usage:</p> <pre><code>  python odk_client.py --id 1 --form 1 --xform upload file1.csv,file2.pdf\n</code></pre> <p>Note: Replace \"1\" with the actual IDs of the project and XForm you want to access.</p>"},{"location":"about/odk_client/#create-a-new-xform-and-upload-these-two-attachments","title":"Create a new XForm, and upload these two attachments","text":"<p>These two attachments are input for select_from_file in the survey sheet. For osm_fieldwork, they are usually a list of municipalities and towns.</p> <pre><code>./osm_fieldwork/odk_client.py --id 4 --form waterpoints --xform create osm_fieldwork/xlsforms/waterpoints.xml osm_fieldwork/xlsforms/towns.csv osm_fieldwork/xlsforms/municipality.csv\n</code></pre>"},{"location":"about/odk_client/#to-create-a-new-xform-and-upload-two-attachments-follow-these-steps","title":"To create a new XForm and upload two attachments, follow these steps:","text":"<ul> <li> <p>Create a new XForm using the ODK XLSForm syntax. You can use any tool that supports this syntax, such as ODK Build or Excel. Save the XLSForm file as \"<code>waterpoints.xml</code>\".</p> </li> <li> <p>Next, prepare two CSV files: \"<code>towns.csv</code>\" and \"<code>municipality.csv</code>\". These CSV files should contain the list of municipalities and towns, respectively, that will be used as input for the \"<code>select_from_file</code>\" function in the survey sheet.</p> </li> <li> <p>Once you have these files ready, use the osm-fieldwork tool to convert the XLSForm and CSV files into an ODK form. To do this, open a terminal or command prompt and navigate to the \"<code>osm-fieldwork</code>\" directory. Then, run the following command:</p> <p>./osm-fieldwork/odk_client.py --id 4 --form waterpoints --xform create osm-fieldwork/xlsforms/waterpoints.xml osm-fieldwork/xlsforms/towns.csv osm-fieldwork/xlsforms/municipality.csv</p> </li> </ul> <p>This command will create a new form with the ID \"4\" and the name \"waterpoints\", using the XLSForm file and the two CSV files as input. The resulting ODK form can be uploaded to an ODK server for use in data collection.</p> <p>Make sure to update the file paths in the command to match the actual location of your XLSForm and CSV files. Additionally, ensure that your CSV files are properly formatted according to the ODK specifications.</p>"},{"location":"about/odk_client/#project-requests_1","title":"Project Requests","text":""},{"location":"about/odk_client/#list-all-the-projects-on-an-odk-central-server","title":"List all the projects on an ODK Central server","text":"<pre><code>./osm_fieldwork/odk_client.py --server projects\n</code></pre>"},{"location":"about/odk_client/#delete-a-project-from-odk-central","title":"Delete a project from ODK Central","text":"<pre><code>./osm_fieldwork/odk_client.py --server delete --id 2\n</code></pre>"},{"location":"about/odk_client/#app-user-requests","title":"App-user Requests","text":""},{"location":"about/odk_client/#create-a-new-app-user-for-a-project","title":"Create a new app-user for a project","text":"<pre><code>./osm_fieldwork/odk_client.py --appuser create --id 4 foobar\n</code></pre>"},{"location":"about/odk_client/#create-a-qr-code-for-the-app-user-to-access-odk-central","title":"Create a QR code for the app-user to access ODK Central","text":"<pre><code>./osm_fieldwork/odk_client.py -i 4 -f waterpoints -a qrcode -u 'jhAbIwHmYCBObnR45l!I3yi$LbCL$q$saJHkDvgwgtKs2F6sso3eepySJ5tyyyAX'\n</code></pre>"},{"location":"about/odk_client/#delete-an-app-user-from-a-project","title":"Delete an app-user from a project","text":"<pre><code>./osm_fieldwork/odk_client.py --appuser delete --id 4 378\n</code></pre>"},{"location":"about/odk_client/#list-all-app-users-for-a-project","title":"List all app-users for a project","text":"<pre><code>./osm_fieldwork/odk_client.py  --id 4 --project app-users\n</code></pre>"},{"location":"about/odk_client/#bulk-operations","title":"Bulk operations","text":"<p>Some commands require multiple queries to ODK Central. As FMTM creates many, many app-users and xforms, it's necessary to be able to clean up the database sometimes, rather than go through Central for hundreds, or thousands of app-users.</p>"},{"location":"about/odk_client/#delete-multiple-app-users-from-a-project","title":"Delete multiple app-users from a project","text":"<pre><code>./osm_fieldwork/odk_client.py --appuser delete --id 4 22-95\n</code></pre>"},{"location":"about/odk_client/#generate-qrcodes-for-all-registered-app-users","title":"Generate QRcodes for all registered app-users","text":"<pre><code>./osm_fieldwork/odk_client.py --id 4 --bulk qrcodes --form waterpoints\n</code></pre> <p>which generates a png file for each app-user, limited to that project.</p>"},{"location":"about/odk_merge/","title":"odk_merge.py","text":"<p>This program conflates the data collected using ODK Collect with existing OSM data. Many buildings in OSM were from imports of AI derived building footprints, and the only tags are building=yes. When doing ground data collection, in addition to collecting new data, you want to add or correct tags in existing OSM data.</p> <p>The file of collected data is downloaded as a CSV file from ODK Central. Then it's converted to OSM XML using CSVDump.py. Once converted, to OSM XML format, all tags can be merged or added to existing OSM data.</p>"},{"location":"about/odk_merge/#usage","title":"Usage","text":"<pre><code>usage: odk_merge.py [-h] [-v] [-c ODKFILE] [-f OSMFILE] [-o OUTFILE] [-b BOUNDARY]\n\nThis program conflates ODK data with existing features from OSM.\n\noptions:\n-h, --help            show this help message and exit\n-v, --verbose         verbose output\n-c ODKFILE, --odkfile ODKFILE - ODK CSV file downloaded from ODK Central\n-f OSMFILE, --osmfile OSMFILE - OSM XML file created by osm_fieldwork\n-o OUTFILE, --outfile OUTFILE - Output file from the merge\n-b BOUNDARY, --boundary BOUNDARY - Boundary polygon to limit the data size\n</code></pre> <p>The boundary file is a polygon to limit the dataset size, useful when using downloaded OSM data for entire countries, or using a large database. Most ODK data files are not usually very large. It can be in any format, but GeoJson is the most common one.</p> <p>To specify a database as the OSM source, the input file gets prefixed with pg:, followed by the database name. Otherwise use a disk file.</p> <p>The ODK source is an OSM XML file created by CSVDump.py, where all the tags have been converted from the ODK Central submission download. The output file is in OSM XML format, and contains modified entries where existing data has the new tags added.</p>"},{"location":"about/odk_merge/#examples","title":"Examples","text":""},{"location":"about/odk_merge/#example-1-merge-odk-data-into-an-existing-osm-file","title":"Example 1: Merge ODK data into an existing OSM file:","text":"<pre><code>odk_merge.py -f /path/to/existing.osm -c /path/to/odk_data.csv -o /path/to/output.osm\n</code></pre> <p>This command will merge the data collected through ODK into the existing.osm file, adding new tags or updating existing ones based on the data in the odk_data.csv file. The resulting merged data will be written to the output.osm file.</p>"},{"location":"about/odk_merge/#example-2-merge-odk-data-into-an-existing-osm-file-within-a-specific-boundary","title":"Example 2: Merge ODK data into an existing OSM file within a specific boundary:","text":"<pre><code>odk_merge.py -f /path/to/existing.osm -c /path/to/odk_data.csv -o /path/to/output.osm -b /path/to/boundary.geojson\n</code></pre> <p>This command is similar to the previous one, but it limits the merged data to the area defined by the boundary.geojson file.</p>"},{"location":"about/odk_merge/#example-3-merge-odk-data-into-an-existing-osm-database","title":"Example 3: Merge ODK data into an existing OSM database:","text":"<pre><code>odk_merge.py -f pg:osm -c /path/to/odk_data.csv -o /path/to/output.osm\n</code></pre> <p>This command merges the ODK data into an existing OSM database instead of a file. The pg:osm argument specifies the name of the OSM database.</p>"},{"location":"about/odk_merge/#example-4-merge-odk-data-into-an-existing-osm-database-within-a-specific-boundary","title":"Example 4: Merge ODK data into an existing OSM database within a specific boundary:","text":"<pre><code>odk_merge.py -f pg:osm -c /path/to/odk_data.csv -o /path/to/output.osm -b /path/to/boundary.geojson\n</code></pre> <p>This command is similar to the previous one, but it limits the merged data to the area defined by the boundary.geojson file.</p>"},{"location":"about/osm2favorites/","title":"osm2favorities.py","text":"<p>This is a simple utility that generates a GPX file from OSM data or a GeoJson file for Osmand. This makes the data a available under My Places in the Osmand menu.This is useful for a field mapping project that covers a large area, but with a few small areas of interest. This makes them all readily available for navigation. For some features this program also adds Osmand styling to change the displayed icons and colors.</p>"},{"location":"about/osm2favorites/#options","title":"options:","text":"<pre><code>-h, --help            show this help message and exit\n-v, --verbose         verbose output\n-i INFILE, --infile INFILE\n                    The data extract\n</code></pre>"},{"location":"about/osmfile/","title":"Osmfile.py","text":"<p>Osmfile.py is a Python module that provides functionality for writing OpenStreetMap (OSM) XML format output files. It is used as part of the osm-fieldwork toolset, and can be used as part of a larger Python application. Currently it is only used by the CSVDump.py program.</p> <p>When used, osmfile.py takes a Python data structure containing OSM data as input and generates an OSM XML format output file. The data structure consists of nested Python dictionaries and lists, with each dictionary representing an OSM node, way or relation, and each list representing a set of nodes, ways or relations.</p> <p>For example, consider the following Python data structure representing a single OSM node:</p> <pre><code>node = {\n    'id': 1234,\n    'lat': 51.5074,\n    'lon': -0.1278,\n    'tags': {\n        'name': 'Big Ben',\n        'amenity': 'clock'\n    }\n}\n</code></pre> <p>To write this node to an OSM XML format output file using osmfile.py, you would first create a new osmfile.OsmWriter object, and then call the <code>write()</code> method, passing in the node dictionary as an argument:</p> <pre><code>from osmfile import OsmFile\n\nwriter = OsmFile('output.osm')\nnode_xml = writer.createNode(node)\nway_xml = writer.createWay(way)\nrelation_xml = writer.createRelation(relation)\nwriter.add_tag('1234', 'amenity', 'post_office')\nwriter.write(node_xml)\nwriter.write(way_xml)\nwriter.write(relation_xml)\nwriter.close()\n</code></pre> <p>This would create XML code for the node, way, and relation using createNode(), createWay(), and createRelation() respectively. These methods return a string of XML code which is then written to the output file using writer.write(). The add_tag() method can be used to add additional tags to any of the elements being written to the file.</p> <pre><code>&lt;node id=\"1234\" lat=\"51.5074\" lon=\"-0.1278\"&gt;\n&lt;tag k=\"name\" v=\"Big Ben\"/&gt;\n&lt;tag k=\"amenity\" v=\"clock\"/&gt;\n&lt;/node&gt;\n</code></pre> <p>Osmfile.py also provides methods for writing OSM ways and relations to output files, and for adding tags to existing OSM nodes, ways and relations.</p> <p>To write an OSM way to an output file, you would create a dictionary representing the way, with a <code>nodes</code> key containing a list of the node IDs that make up the way. For example:</p> <pre><code>way = {\n    'id': 5678,\n    'nodes': [1234, 5678, 9012],\n    'tags': {\n        'name': 'Oxford Street',\n        'highway': 'primary'\n    }\n}\n\nwriter.write_way(way)\n</code></pre> <p>This would write the following XML code to the output file:</p> <pre><code>&lt;way id=\"5678\"&gt;\n    &lt;nd ref=\"1234\"/&gt;\n    &lt;nd ref=\"5678\"/&gt;\n    &lt;nd ref=\"9012\"/&gt;\n    &lt;tag k=\"name\" v=\"Oxford Street\"/&gt;\n    &lt;tag k=\"highway\" v=\"primary\"/&gt;\n&lt;/way&gt;\n</code></pre> <p>To write an OSM relation to an output file, you would create a dictionary representing the relation, with a <code>members</code> key containing a list of dictionaries representing the members of the relation. Each member dictionary should have <code>type</code>, <code>ref</code> and <code>role</code> keys, specifying the type of OSM object (node, way or relation), the ID of the object, and the role of the object in the relation. For example:</p> <pre><code>relation = {\n    'id': 7890,\n    'members': [\n        {'type': 'way', 'ref': 5678, 'role': 'outer'},\n        {'type': 'node', 'ref': 1234, 'role': 'admin_centre'}\n    ],\n    'tags': {\n        'name': 'London Borough of Westminster',\n        'type': 'boundary'\n    }\n}\n\nwriter.write_relation(relation)\n</code></pre> <p>This would write the following XML code to the output file:</p> <pre><code>&lt;relation id=\"7890\"&gt;\n    &lt;member type=\"way\" ref=\"5678\" role=\"outer\"/&gt;\n    &lt;member type=\"node\" ref=\"1234\" role=\"admin_centre\"/&gt;\n    &lt;tag k=\"name\" v=\"London Borough of Westminster\"/&gt;\n    &lt;tag k=\"type\" v=\"boundary\"/&gt;\n&lt;/relation&gt;\n</code></pre> <p>In addition to writing new OSM objects to an output file, osmfile.py also provides methods for adding tags to existing objects. To add a tag to an OSM object, you would call the <code>add_tag()</code> method, passing in the object's ID, the tag key and the tag value:</p> <pre><code>writer.add_tag('1234', 'amenity', 'post_office')\n</code></pre> <p>This would add the following XML code to the output file, as a child of the existing <code>node</code> element with ID <code>1234</code>:</p> <pre><code>&lt;tag k=\"amenity\" v=\"post_office\"/&gt;\n</code></pre> <p>Note that the <code>OsmWriter</code> class also provides methods for closing the output file and flushing any buffered data to disk. You should call the <code>close()</code> method once you have finished writing all of your OSM data to the output file.</p>"},{"location":"about/programs/","title":"OSM Fieldwork Programs","text":"<p>OSM Fieldwork contains a few standalone utility programs for converting data from ODK Collect and the ODK Central server, and a few support modules. You can install from the  source tree using:</p> <pre><code>pip install .\n</code></pre> <p>or you can install the package from PyPi.org:</p> <pre><code>pip install osm-fieldwork\n</code></pre>"},{"location":"about/programs/#make_data_extractpy","title":"make_data_extract.py","text":"<p>The <code>make_data_extract.py</code> program is used to extract OpenStreetMap (OSM) data for use with the <code>select_one_from_file</code> function in ODK Collect. This function allows users to select from a list of options generated from an external file. The <code>make_data_extract.py</code> program creates a data extract that can be used as an external file with the <code>select_one_from_file</code> function. There is more detailed information on the program for making data extracts here.</p>"},{"location":"about/programs/#csvdumppy","title":"CSVDump.py","text":"<p>CSVDump.py is program converts a CSV file downloaded from ODK Central to OpenStreetMap (OSM) XML format. The tool can be useful for users who want to work with OpenStreetMap data and want to convert ODK Central data into a compatible format. There is more detailed information on the program for converting ODK to OSM here</p>"},{"location":"about/programs/#odk_mergepy","title":"odk_merge.py","text":"<p>odk_merge.py is a program for conflating the OSM XML file produced from CSVDump.py into with the data extract. This merges tags that have been added or change by ODK Collect with exiting OSM data, The result can be loaded into JOSM and after validation, uploaded to OSM.</p>"},{"location":"about/programs/#osm-fieldwork-modules","title":"OSM Fieldwork Modules","text":""},{"location":"about/programs/#sqlitepy","title":"sqlite.py","text":"<p>This module creates mbtiles or sqlitedb files for basemaps. It's just a wrapper around the existing sqlite3 module to create the output files.</p>"},{"location":"about/programs/#osmfilepy","title":"osmfile.py","text":"<p>Osmfile.py is a module that writes OSM XML files for JOSM. It assumes the data has already been converted using CSVDump. This module is only used from within CSVDump.py. OSM XML format is needed as it's the only format that supports conflation with upstream OSM data. More on writing OSM XML is here.</p>"},{"location":"about/programs/#filter_datapy","title":"filter_data.py","text":"<p>filter_data.py is a program for filtering data extracts. Since an extract can only include tags and values in the XLSform, thuis scans the XLSForm, and is used to remove anything not included in the choices sheet. While usually used as a module, if run standalone it can also compare an XLSForm with the taginfo database to help modify the data models.</p>"},{"location":"about/programs/#convertpy","title":"convert.py","text":"<p>The convert.py module is part of the osm_fieldwork package and provides functionality for converting ODK forms between different formats using a YAML configuration file. More detailed information on this module is here</p>"},{"location":"about/programs/#yamlfilepy","title":"yamlfile.py","text":"<p>This reads in the yaml config file with all the conversion information into a data structure that can be used when processing the data conversion. More detail on this module is here.</p>"},{"location":"about/programs/#odk2csvpy","title":"odk2csv.py","text":"<p>Odk2csv.py is a command-line tool that is part of the osm-fieldwork package. Its main purpose is to convert an Open Data Kit (ODK) XML instance file to CSV format, which can be easily imported into ODK Central for analysis. This is primarily only used when working offline, as it removes the need to access ODK Central.</p> <pre><code>options:\n -h, --help                       - show this help message and exit\n -v, --verbose                    - verbose output\n -i INSTANCE, --instance INSTANCE - The instance file from ODK Collect\n</code></pre>"},{"location":"about/programs/#works-in-progress","title":"Works In Progress","text":""},{"location":"about/programs/#odkdumppy","title":"ODKDump.py","text":"<p>ODKDump.py is a Python module that is part of the OSM-Fieldwork toolset for converting Open Data Kit (ODK) data into various formats. It is used to parse the contents of an ODK Collect Instance file into a readable format. This module currently is not finished, instead use the CSVDump.py utility instead.</p>"},{"location":"about/programs/#odkformpy","title":"ODKForm.py","text":"<p>ODKForm.py parses the XLSXForm, and creates a data structure so any code using this class can access the data types of each input field. This module currently is not finished. It turns out know the input data types is not probably neccesary if we stick to processing the CSV files.</p>"},{"location":"about/programs/#odkinstancepy","title":"ODKInstance.py","text":"<p>ODKInstance.py parses the ODK Collect instanceXML file, and creates a data structure so any code using this class can access the collected data values. This module currently is not finished, instead use the odk2csv.py utility instead.</p>"},{"location":"about/user-manual/","title":"Osm-Fieldwork User Manual","text":"<p>The osm-fieldwork project is a collection of utilities useful for field data collection, focused on OpenStreetMap (OSM) and OpenDataKit (ODK). Both of these are used heavily for humanitarian and emergency response by many organizations. The problem is these two projects were never designed to work together, so this project was born to fill the gaps. Included are a few other useful utilities for field mapping.</p> <p>This project is also currently part of the backend for the FMTM project, but all of the data processing can also be run standalone, and also works fully offline. All the standalone programs run in a terminal, and are written in Python.</p>"},{"location":"about/user-manual/#opendatakit-odk","title":"OpenDataKit (ODK)","text":"<p>OpenDataKit is a format for collecting data on mobile devices, including the spatial coordinates of that data item. The primary source file is a spreadsheet called an XLSForm, which gets converted to an XForm using the xls2xform program. An XForm is is in XML format. All collected data is stored as an instance file, also in XML format on the mobile device, but of course is a different schema than the XForm. Once the data is collected it gets uploaded to an ODK Central server. From there you can download the collected data, called submissions, in CSV or JSON format. The JSON format works better. Here's where the conversion project starts, how to process the downloaded data into something we can upload to OpenStreetMap efficiently.</p> <p>All of the XLSForms included in this project have all been carefully edited to enable a good clean conversion to OSM XML. More information on how to modify the conversion is here. If you base any custom XLSForms from this library, you can also update the conversion criteria. These XLSForms can also be downloaded from FMTM.</p>"},{"location":"about/user-manual/#field-mapping-tasking-manager-fmtm","title":"Field Mapping Tasking Manager (FMTM)","text":"<p>The FMTM is a project to coordinate field data collection in a similar way as the HOT Tasking Manager. But other than the ability to break up a big area into tasks, the rest works very differently. Often mangaing a group doing field mapping is a bit like herding cats. Plus the mappers often aren't sure where they should be mapping, or when they are finished. In addition, it is now possible to load a data extract from OSM into ODK Collect, and use that data to set the default values when collecting the data so the mapper doesn't have to do it. FMTM handles the creation of the data extract, as well as processing the data into a format suitable to edit with JOSM or QGIS. The FMTM backend is a FastAPI wrapped around this project.</p>"},{"location":"about/user-manual/#getting-started","title":"Getting Started","text":"<p>This project is available from PyPi.org, and can be installed like this:</p> <pre><code>pip install osm-fieldwork\n</code></pre> <p>It contains multiple programs, each one that handles a specific part of the conversion process. Each program is a single class so it can be used as part of a FastAPI backend, but also runs standalone for debugging, and working offline. These are all terminal based, as the website frontend is the actual GUI.</p> <ul> <li>json2osm</li> <li>Convert JSON from Central to OSM XML</li> <li>csv2osm</li> <li>Convert CSV from Central to OSM XML</li> <li>odk2csv</li> <li>Convert the ODK Instance to CSV</li> <li>odk2geojson</li> <li>Convert the ODK Instance to GeoJson</li> <li>odk_merge</li> <li>Conflate POIs from Collect with existing OSM data</li> <li>odk_client</li> <li>Remotely control an ODK Central server</li> </ul> <p>You can also to run the terminal based programs from the source tree, which can be gotten from here:</p> <pre><code>git clone git@github.com:hotosm/osm-fieldwork.git\n</code></pre>"},{"location":"about/user-manual/#processing-submissions","title":"Processing Submissions","text":"<p>This section will focus on converting the JSON format, but the process for converting the CSV submissions is the same. The JSON format seems to be more complete for some XLSForms, so it's preferred. The first step is converting it to OSM XML format, so it can be loaded into JOSM and edited. A YAML based config file is used to convert the JSON format you just downloaded into the OSM XML format.</p> <p>The initial problem is neither the CSV or the JSON format stores the coordinates in a way any editing program wants them. So that's the most important part of the conversion process, generating a data file with spatial coordinates in the right syntax. The conversion process generates two output files, one in OSM XML format, the other in GeoJson format. The OSM XML one has had the data filtered, not everything collected is for OSM. But all the data goes in the GeoJson file, so nothing is lost. Since the GeoJson format does not have to follow OSM syntax, not all the tags and values may be similar to what OSM expects, but that's not a problem for our use case.</p> <p>The config file for conversion has 3 sections, one for all the conversion data, one for data to ignore completely, and a private section for the GeoJson file. The stuff to ignore is extraneous fields added by ODK Collect, like deviceID. Modifying the conversion is straight forward as it's mostly just replacing one set of strings with another.</p> <p>For any of the XLSForms in this project's library, the configuration is already done, but any custom XLSForms will need to modify it to get a good conversion, or fix it in JOSM later. For a one-off project, like an import, I usually get lazy and fix it in JOSM. But for anything used several times, that gets old, so it's better to improve the config file.</p> <p>To convert the JSON format file downloaded for ODK Central, run this program:</p> <p>json2osm.py -i Submissions.json json2osm.py -i Submissions.json -y custom.yaml</p> <p>or for the CSVfile:</p> <pre><code>CSVDump.py -i Submissions.csv\nCSVDump.py -i Submissions.csv -u custom.yaml\n</code></pre> <p>which produces a Submissions.osm and Submissions.geojson files from that data. The OSM XML file may have tags that got missed by the conversion process, but the advantage is now all the data can be viewed and edited by JOSM. If you want a clean conversion, edit the config file and use that as an alternate for converting the data.</p> <pre><code>json2osm -i Submissions.json -x custom.yaml\n</code></pre>"},{"location":"about/user-manual/#data-conflation","title":"Data Conflation","text":"<p>Now you have a file that can be viewed or edited, but it's all collected, but some of the features may already exist in OSM. This can be done manually in JOSM, which is ok for small datasets, but it's easier to apply a little automated help. It's possible to find similar features in OSM that are near the data we just collected for a building, but has the same business name. How to conflate the collected data with existing OSM data is another document.</p> <p>To just use the conflation software requires setting up a postgres database containing the OSM data for the county, region, state, country, ect... You can also use the data extract from FMTM, as it covers the same area the data was collected in. FMTM allow you to download the data extract used for this task. Postgres works much faster, but the GeoJson data extract works too as the files per task are relativly small.</p> <pre><code>odk_merge.py Submissions.osm PG:\"nepal\" -b kathmanu.geojson\nor\nodk_merge.py Submissions.osm kathmandu.geojson\n</code></pre> <p>In this example, the OSM XML file from the conversion process uses a local postgres data with the country of Nepal loaded into it. You can also specify an alternate boundary so the conflation will use a subset of the entire database to limit the amount of data that has to be queried.</p> <p>Each feature in the submission is queried to find any other features with 2 meters where any tags match. Both POIs and buildings are checked for a possible match. Often the building has \"building=yes\" from remote mapping, so we'd also want to merge the tags from the collected data into the building way. Multiple shops within the same building remain as a POI in that building.</p> <p>There is much more detail on this program here.</p>"},{"location":"about/user-manual/#utility-programs","title":"Utility Programs","text":""},{"location":"about/user-manual/#making-basemaps","title":"Making basemaps","text":"<p>Basemaps are very useful when using ODK Collect in areas where the map data is poor. Imagery is particular is very useful, as you can use that to select a location other than where you are standing. This project has a utility that makes basemaps from several sources. It builds a local tile store, so larger areas can be downloaded and in the field when offline, smaller basemaps can be made from the tile store. Since downloading map tiles is very time consuming, I usually download larger areas and let it download for a few days.</p> <pre><code>basemapper -s esri -b Pokara.geojson -z 8-15 -o pokara.mbtiles\n</code></pre> <p>This command will download all the map tiles from ESRI into an XYZ tile store for zoom levels 8 to 15. Since downloading imagery is slow, I often download larger areas, and then use a subset of the tiles to make smaller basemaps. The mbtiles file can be manually loaded into ODK Collect as a layer, and used to adjust the location of the POI when mapping.</p> <p>Since it often useful for navigation, basemapper can also produce a basemap from the same map tiles for Osmand. This is very useful when in areas with little map data, for example during a remote backcountry trip. This example downloads Bing imagery for Pokara, Nepal.</p> <p>basemapper -s bing -b Pokara.geojson -z 8-19 -o pokara.sqlitedb</p> <p>There is much more detail on this program here.</p>"},{"location":"about/user-manual/#converting-for-an-instance-file","title":"Converting for an Instance File","text":""},{"location":"about/user-manual/#odk2osmpy-odk2geojsonpy-odk2csvpy","title":"odk2osm.py, odk2geojson.py, odk2csv.py","text":"<p>These programs read the XML format used by ODK Collect for Instance files. Since each submission has a separate Instance file, this takes a regular expression, and produces a single output file. This is only used when working offline, so it's possible to edit the recently collected data and update the map data. Very useful when working offline during big disasters.</p> <pre><code>odk2osm -i Highways Paths_2023-07-17\\*\n</code></pre> <p>On your phone, you can find the instance files here:</p> <p>/sdcard/Android/data/org.odk.collect.android/files/projects/[UUID]/instances</p> <p>You can also manually update your data extracts by copying them to /sdcard/Android/data/org.odk.collect.android/files/projects/[UUID]/forms/[Form name]-media/</p> <p>And manually update the XForm by copying them to /sdcard/Android/data/org.odk.collect.android/files/projects/[UUID]/forms/</p>"},{"location":"about/user-manual/#managing-odk-central","title":"Managing ODK Central","text":"<p>[ODK Central](https://docs.getodk.org/central-intro/ is the server side of ODK Collect. It's where XForms are downloaded from, and where submissions go after being sent by Collect. As there are a lot of options, this program is not very user friendly as it's primarily used as part of the backend for the FMTM project, and most people would just use the Central website.</p> <p>However, this can be useful for scripting the server. For example to list all the projects on a remote Central server:</p> <pre><code>odk_client -s projects\n</code></pre> <p>And this lets you download all the submissions to project number 19 and using the XLSForm for buildings.</p> <p>odk_client -v -i 19 -f buildings -x json</p> <p>There is much more detail on this program here.</p>"},{"location":"about/xlsforms/","title":"Improving XLSXForms","text":""},{"location":"about/xlsforms/#document-summary","title":"Document Summary","text":"<p>This documents the process of improving XLSXForms for better mapper efficiency and stability.</p>"},{"location":"about/xlsforms/#background","title":"Background","text":"<p>XLSXForms provides a way to define input fields, their data types, and any constraints or validation rules that apply. It uses the XLSX file format and allows users to create forms by editing spreadsheets. It is compatible with ODK and other data collection platforms.</p> <p>XLSForm is a powerful tool that allows users to create complex forms with advanced functionality, such as conditional questions, complex calculations, and multimedia inputs. However, it has a complex syntax, and it can be difficult for new users to learn. There are a few web-based front-ends for creating and editing XLSForms, but they don't support all of the advanced features of the format.</p> <p>To use an XLSForm with a mobile app, it needs to be converted to the XML-based XForm format used by the apps. This conversion is done using a utility program called xls2xform which is part of the pyxform python package. Once the XLSForm has been converted to an XForm, it can be loaded onto a mobile device and used to collect data in the field.</p> <p>XLSForms are widely used in the humanitarian and development sectors for data collection, monitoring, and evaluation. It is particularly popular for its flexibility and the ease with which it can be customized to meet specific needs. XLSForm has also been adopted by other platforms, such as Kobo Toolbox and SurveyCTO, making it a widely used standard for creating forms for mobile data collection.</p> <p>The two primary mobile apps used at HOT that use XLSForms are OpenMapKit(OMK), and ODK Collect. OMK uses the same XLSX format as ODK Collect or Kobo Collect, so any comments about improving XLSXForms apply all of them. Using OMK has been depreciated as it's functionality has been incorporated into ODK Collect. It is unmaintained, and no longer works on newer phones.</p> <p>Improving XLSXForm design can lead to more efficient data collection, allowing more good quality data to be collected in less time. Also for those of us use ODK based apps to collect data for OpenStreetMap(OSM), a well designed XLSForm is easier to convert and upload to OSM.</p>"},{"location":"about/xlsforms/#opendatakit","title":"OpenDataKit","text":"<p>OpenDataKit (ODK) is a software suite that includes a mobile app called ODK Collect and a server called ODK Central. ODK Collect is designed to run on Android devices and enables users to collect data in the field using forms created in the XLSXForms format. ODK Central is a server application that enables users to manage forms, data, and users, as well as to visualize and export collected data.</p> <p>ODK Collect offers a wide range of functionality, including the ability to capture photos, videos, and audio recordings, and to collect GPS coordinates and other metadata. It also supports complex data types, such as repeat groups and geoshapes, and can be customized with the use of various add-ons.</p> <p>While OMK was an earlier version of the ODK Collect app, most of its functionality has been migrated to ODK Collect. However, this document also provides information on how to modify old XForms from the OMK app to work with ODK Collect. ODK Collect is actively maintained, with regular updates and support services provided by the organization behind it.</p>"},{"location":"about/xlsforms/#openmapkit","title":"OpenMapKit","text":"<p>OpenMapKit (OMK) is an extension of OpenDataKit (ODK) that allows users to create professional quality mobile data collection surveys for field data collection. The tool was designed to simplify the process of collecting data for OpenStreetMap (OSM) in the field.</p> <p>It was sponsored by the Red Cross and included a server and a mobile app that rans on Android operating system. However, the use of OMK is no longer recommended as it has not been maintained for several years and its functionality has been incorporated into ODK. It no longer runs on most newer phones.</p> <p>One of the unique features of OMK was the use of a special field called osm in the survey sheet, which is the first page of the XLSX file. Additionally, OMK looked at another sheet called osm which replaced the existing choices sheet. The values in the osm sheet were designed to closely match the tagging scheme used by OpenStreetMap (OSM).</p> <p>Because it is important to get collected data into OSM, the Humanitarian OpenStreetMap Team has developed a project called OSM Fieldwork, which can handle the conversion from ODK formats into OSM.</p> <p>Overall, while OMK has been a useful tool in the past for data collection, it is no longer actively maintained, and users are encouraged to use ODK instead which offers more advanced functionality and support services.</p>"},{"location":"about/xlsforms/#xlsxform-syntax","title":"XLSXForm Syntax","text":"<p>An XLSXForm is the source file for ODK based tools. This is edited in a spreadsheet program like LibreCalc, Excel, or Google Forms. There are also online build tools, but they fail to utilize the full functionality of XLSXForms. The program xls2xform, which is in the pyxform python package converts the spreadsheet to the format used by ODK Collect. You can also upload the spreadsheet to the ODK Central server, and it will convert it there.</p> <p>This document is just a subset of all of syntax, and focuses on the most commonly used ones. To really dig deep into the XLSForm syntax go that documentation page.</p>"},{"location":"about/xlsforms/#sheet-names","title":"Sheet Names","text":"<p>The sheet names are predefined to have specific functionality as follows, and the column headers are used to determine the functionality of the value in the cells of the spreadsheet. The sheets are Survey, Choices, and Settings. A few columns are required to exist in each sheet, the rest are optional.</p>"},{"location":"about/xlsforms/#survey-sheet","title":"Survey Sheet","text":"<ul> <li>This sheet contains all the questions used for collecting data,     and refers to the actual values for each question which are on the     choices sheet.</li> </ul> <p>These are the mandatory column headers in the survey sheet:</p> <ul> <li>Type - The type of question, the most common ones are text,   select_one, select_multiple., and select_from_file The   second argument in the type column is the keyword used as the   list_name in the choices sheet for selection menus</li> <li>Name - Refers to the name of the choice keyword that would be   the tag in the output OSM file</li> <li>Label - Refers to the question the user sees</li> </ul> <p>The name and label column headers also support different   languages by using a postfix of   ::language appended to it, for example   label::Nepali(np).</p> <p>These are the optional column headers in the survey sheet:</p> <ul> <li>Hint - Optional value display with   the question with further information</li> <li>The hint column also supports different languages by using a     postfix of::languageappended to it, for     example hint::Nepali(np).</li> <li>Default - Optional default value   for a selection.</li> <li>Required - If the value is 1 or   yes, this field must have an answer. If the value is 0 or no or   blank, then it\u2019s optional.</li> <li>Relevant - Allows to set up   conditional display of questions based on other fields.</li> <li>Appearance - This changes how   input fields are displayed on the screen.</li> <li>Calculation - Do a   calculation, used for dynamic values.</li> <li>Choice_filter - Filters choices based on other surbay answers.</li> <li>Parameters - Change the behaviour of input data, or example the size   of images.</li> </ul>"},{"location":"about/xlsforms/#input-types","title":"Input Types","text":"<p>The Survey sheet has several forms of selecting answers. These allow the mapper to enter an interger, text, or select one or multiple items from a menu.</p>"},{"location":"about/xlsforms/#choices-sheet","title":"Choices Sheet","text":"<p>The choices sheet is used to define the values used for the select_one and select_multiple questions on the survey sheet.</p> <p>The mandatory column headers are:</p> <ul> <li>List_name - This is the name of the list as specified in the   select type in the survey sheet.</li> <li>Name - This becomes the value of the tag in the OSM output file.</li> <li>Label - Refers to what is displayed in the select menu.</li> <li>The label column header also supports different languages by   using a postfix of ::language appended to it, for   example label::Nepali(np).</li> </ul>"},{"location":"about/xlsforms/#settings-sheet","title":"Settings Sheet","text":"<p>For the settings sheet, there are 1 mandatory ones, but I usually always add 2 of the optional ones. This is a simple sheet that contains the version of the sheet, and the title of the input form. The version is used by the server and the mobile apps to track changes in the data format, so it should always be updated after changes are made.</p> <ul> <li>form_title - This is what is displayed in ODK Central</li> <li>form_id - This is a unique ID to identify this XForm.</li> <li>version - This is mandatory, and needs to change after major   change. During development when I make many changes I usually use   NOW() which is the current data. Use the date format with no   spaces.</li> </ul>"},{"location":"about/xlsforms/#mapping-answers-to-osm","title":"Mapping Answers to OSM","text":"<p>When designing an XForm whose data is for OSM, the two key columns that determine the tag &amp; value scheme used in the OSM XML format are name in the survey sheet, which becomes the tag, and name in the choices sheet, which becomes the value. If you are using the OSM Fieldwork project, anything that isn't a one to one match with OSM syntax can be specified in the config file for that project. When using OSM Fieldwork, tags &amp; values can also be specified as private data, which goes into a GeoJson file, and anything that is for OSM goes into an OSM XML file. That file can be edited in JOSM.</p>"},{"location":"about/xlsforms/#screen-layout","title":"Screen Layout","text":"<p>ODK supports multiple options to change the layout of the input fields on the screen. In the XLSXForm, this is under the appearance column. There\u2019s many possible options available to change the layout, but here\u2019s a summary of the primary ones.</p> <ul> <li>Minimal - Answer choices appear in a pull-down menu.</li> <li>Field-list - Entire group of questions appear on one screen</li> <li>Parameter-map - Use a basemap to pick the location</li> <li> <p>Quick - Auto-advances the form to the next question after an   answer is selected</p> </li> <li> <p>All fields are grouped together to maximize screen space.</p> </li> <li>When the field-list attribute is set for begin_group, then   multiple questions are on the same screen.</li> <li>The screen can be scrolled if there are more input fields than fit.</li> </ul> type name label appearance begin_group agroup Amenity Details field-list select_one text name Amenity Name minimal select_one amenity amenity Type of Amenity minimal end_group"},{"location":"about/xlsforms/#conditionals","title":"Conditionals","text":"<p>ODK can optionally display input fields for questions based on a selection. Using conditionals allows for a more guided user interface, than just presenting many questions, some of which aren\u2019t relevant to the current mapping task.</p>"},{"location":"about/xlsforms/#using-conditionals","title":"Using Conditionals","text":"<ul> <li>Conditionals go in the relevant column on the survey sheet.</li> <li>A conditional has two parts, the variable from the name column   of a question, and the value to test against, which is one of the   select values.</li> </ul> <p>In the XLSXForm, the spreadsheet should look like this. The amenity menu is only displayed if the answer to the \u201cwhat type of building is this\u201d is \u201ccommercial\u201d.</p> type name label relevant select_one amenity amenity Type of Amenity ${building}=\u2019commercial\u2019 <p>Using conditionals allows for a more dynamic interface, as only relevant questions are displayed. Some questions may have answers that only require a few more questions before being complete. Other answers may generate more questions, for example a commercial building instead of a residence.</p>"},{"location":"about/xlsforms/#grouping","title":"Grouping","text":"<p>ODK supports grouping survey questions together, which when used with conditionals in the relevant column, and attributes from the appearance column, creates a more dynamic user interface. Groups allow more than one question on the screen, which is more efficient than one question per screen, which is the default.</p>"},{"location":"about/xlsforms/#using-grouping","title":"Using Grouping","text":"<ul> <li>Groups are defined in the survey sheet.</li> <li>Using the appearance column can display multiple questions on   each screen, minimizing the actions required to enter data.</li> </ul> <p>Sub groups are also supported. When implemented this way, when the top level group is displayed on the screen, other questions can be dynamically added to the screen display based on what is selected, further minimizing required actions. Using the appearance column settings with grouping can create a more efficient user experience. Ungrouped questions appear one on each screen of the mobile data collection app, requiring one to swipe to the next page for each question.</p> <ul> <li>Begin_group</li> <li>Can use the relevant column to conditionally display the entire group of questions</li> <li>End_group</li> <li>End the group of survey questions</li> </ul> <p>An example grouping would look like this, and the conditional says to only display this group for commercial buildings.</p> type name label relevant select_one type building What type of building ? begin_group amenity ${building}=\u2019commercial\u2019 select_one amenity amenity Type of Amenity text name What is the name ? end_group <p>In this example, the conditional is applied to the entire group of questions, and not just any individual question. Different questions in the group may have different conditionals.</p>"},{"location":"about/xlsforms/#external-datasets","title":"External Datasets","text":"<p>XLSForms support external datasets, which is useful for common choices that can be shared between multiple XLSForms. CSV, XML, or GeoJson files are supported. The one downside is currently external datasets of choices do not support translations, one language only. Each CSV file needs a header that defines at least the name and label columns. The name becomes the tag in OSM, and the label is what ODK Collect displays in the select menu. An id column is also required. Anything else becomes a column in the XLSForm.</p> <p>An example CSV data file would look like this:</p> label name backcountry id ref tourism openfire Test 1 Site 1 yes 5483233147 1 camp_pitch yes Test 2 Site 35 no 6764555904 35 camp_pitch yes <p>For example, these rows in the survey sheet will load the data from the CSV file. The instance is the name of the data file, minus the suffix. The item is what the XForm has in the name column for the select_one_from_file. Then the last part is the column from the OSM data. Whenever the value of test is changed, the trigger goes off, and the value is recalculated and becomes the default value for the survey question.</p> type name label calculation trigger choice select_one_from_file test.csv test CSV test true() calculate xname Name instance('test')/root/item[name=${test}]/label ${test} text debug Name is ${xname} ${test}"},{"location":"about/xlsforms/#geojson-files","title":"GeoJson Files","text":"<p>An external file in GeoJson format works slightly differently, as it also contains GPS coordinates. This allows ODK Collect to display data on the map as an overlay that can be selected. This lets us make a data extract from OSM data and edit it. In OSM, many buildings are tagged building=yes, as that\u2019s about all you can do when doing remote mapping off satellite imagery. ODK Collect can\u2019t handle polygons yet, so a data extract has to use only POIs. To use a GeoJson file, just change the file name in this example. The only other difference is that since the GeoJson data file contains GPS coordinates, you can get either a map or a normal selection menu. To get the map view, put map in the appearance column.</p> <p>When using a GeoJson data file, after opening the XForm, you\u2019ll get a button to select an existing POI. That\u2019ll open either the menu, or the map. For the map view, you\u2019ll see blue markers where the existing features are, Touching an icon loads that data into ODK Collect. You can access the values in the OSM data the same as the above example.</p>"},{"location":"about/xlsforms/#openstreetmap-data","title":"OpenStreetMap Data","text":"<p>OpenStreetMap (OSM) is a popular tool for mapping and collecting geographic data, and many OSM mappers have wanted the ability to edit data in the field. While mobile apps like StreetComplete or Vespucci allow for this, they don't focus on humanitarian data collection, which can lead to incomplete tags on many features. Until recently, OSM mappers collected a new point of interest (POI) in the field and merged the data manually later on using an editor like JOSM. However, with the addition of functionality to ODK Collect, it's now possible to load data from OSM into the app and use XForms to improve feature data, achieving tag completeness and limiting tag values to accepted values.</p> <p>In the past, if a mapper collected a new point of interest (POI) in the field, they would have to manually merge the data later using an editor like JOSM because OSM data typically had few tags beyond building=yes due to the majority of features being added by remote mapping. However, with the recent addition of functionality in ODK Collect, it is now possible to load data from OSM into ODK Collect. This allows for the use of an XForm to improve feature data, which achieves tag completeness for a feature and limits the tag values to accepted values.</p> <p>To create a data extract from OSM, one can use Overpass Turbo or Postgres. Each tag in OSM becomes a column in an XForm, and the column names are used to reference the data from within the XForm. If you are using the OSM data to set the default value for a select_one_from_file, then every possible value used for that tag needs to be in the choices sheet. Otherwise, you will get an error such as doctor is not in the choices for healthcare.</p> <p>Using OSM in ODK Collect requires two data conversion processes. The first step is to produce the data extract. Since the goal is to convert the data from ODK into OSM, OSM standard tags should be used in the name column in the survey and choices sheets. When doing a query to Overpass or Postgres, the column name will conflict with what is in the survey sheet, so the data extract needs to use something else. For Postgres, this is easy as you can use the AS command in the query to rename the column to whatever you want. Abbreviations or the OSM tag's name are often used as variable names internally, but the important thing is to ensure that they are unique and do not conflict with other names in the XForm. There is a much more detailed document on using OSM data extracts in this Dealing with External Data in ODK document.</p> <p></p>"},{"location":"about/xlsforms/#converting-from-omk-to-odk","title":"Converting from OMK to ODK","text":"<p>The OMK mobile app was used for collecting location data using the GPS on the device, or tapping on a basemap. Because that functionality is now in ODK, the usage of the OMK mobile app is not required, and is not maintained and may be unreliable. This section is only useful if you find yourself with an old XForm that you want to edit and reuse, as none of it applies to ODK or Kobo Collect.</p>"},{"location":"about/xlsforms/#step-1-prepare-data","title":"Step 1 - Prepare Data","text":"<p>The first step is to copy the contents of the osm sheet into the choices sheet, The other option is to delete the choices sheet, and then rename the osm sheet to choices.</p>"},{"location":"about/xlsforms/#step-2-migrate-questions","title":"Step 2 - Migrate Questions","text":"<p>The next step is to migrate the questions. The osm keyword in the survey sheet is followed by a variable name, for example in this table, building_tags is the variable. When looking at the choices sheet, every row using the building_tag keyword now has to become a question on the survey sheet.</p> type name label required osm building_tags osm_building Building Form yes <p>In the choices sheet, we see this existing data.</p> list_name name label building_tags name Name of this building building_tags building:material What is it made from ? building_tags building:roof What is the roof made of ? <p>Cut &amp; paste these rows from the choices sheet, and paste them into the survey sheet. Then prefix the variable with selct_one or select_multiple. Drop the prefix used in the choices sheet and simplify it.</p> type name label text name Name of this building select_one building:material material What is it made from ? select_one building:roof roof What is the roof made of ?"},{"location":"about/xlsforms/#step-3-get-coordinates","title":"Step 3 - Get Coordinates","text":"<p>The last step is replacing the keyword that used to start OMK, with the ODK way. There are three ODK keywords that can be used to get a location.</p> <ul> <li>Geopoint - Collect a single location</li> <li>Geoshape - Collect at least 3 points and the ends are closed</li> <li>Geotrace - Collect a trace of a line</li> </ul> <p>By default these keywords only allow you to get the location of where the user is located. If you want to use a basemap and tap on the screen where you want to get the location, add placement-map into the appearances column.</p> <p>After doing these three steps, your XLSXForm is converted to not use the OMK app anymore.</p>"},{"location":"about/xlsforms/#xlsxform-suggestions","title":"XLSXForm Suggestions","text":"<p>Since mobile data collection often involves gathering many of the same types of data, setting defaults helps reduce the number of user actions needed to collect data. When collecting multiples of the same type of data,good defaults can record data  even when only the location has changed.</p>"},{"location":"about/yamlfile/","title":"Yamlfile","text":""},{"location":"about/yamlfile/#yamlfilepy","title":"yamlfile.py","text":"<p>This reads in the yaml config file with all the conversion information into a data structure that can be used when processing the data conversion.</p> <p><code>yamlfile.py</code> is a module that reads in a YAML config file containing information about how to convert data between different formats. The config file contains a list of conversion rules, where each rule specifies the source format, the target format, and any additional information needed to perform the conversion. The module parses the YAML file and creates a Python object representing the conversion rules, which can be used by other code in the conversion process.</p> <p>To use <code>yamlfile.py</code>, you first need to create a YAML config file containing the conversion rules. Here's an example of a simple YAML config file that converts CSV files to ODK Collect forms:</p> <pre><code>- source: csv\ntarget: odk\nsettings:\n    form_id: my_form\n    form_title: My Form\n    form_version: 1.0\n    csv_delimiter: \",\"\n</code></pre> <p>This rule specifies that CSV files should be converted to ODK Collect forms, with the specified settings. The <code>settings</code> dictionary contains additional information needed to perform the conversion, such as the form ID, form title, form version, and the delimiter used in the CSV file.</p> <p>Once you have created the YAML config file, you can use <code>yamlfile.py</code> to read it into a Python object. Here's an example of how to use the <code>read_yaml_file()</code> function to read the YAML config file:</p> <pre><code>import yamlfile\n\nconfig_file = 'my_config.yaml'\nconversion_rules = yamlfile.read_yaml_file(config_file)\n</code></pre> <p>This will read the <code>my_config.yaml</code> file and return a Python list containing the conversion rules.</p> <p>You can then use the conversion rules to perform the actual data conversion. Here's an example of how to use the <code>get_conversion_rule()</code> function to get the conversion rule for a specific source and target format:</p> <pre><code>import yamlfile\n\nconfig_file = 'my_config.yaml'\nconversion_rules = yamlfile.read_yaml_file(config_file)\n\nsource_format = 'csv'\ntarget_format = 'odk'\nconversion_rule = yamlfile.get_conversion_rule(conversion_rules, source_format, target_format)\n\n# Perform the conversion using the conversion rule\n</code></pre> <p>This will search through the list of conversion rules for a rule that matches the specified source and target format, and return the matching rule. You can then use the conversion rule to perform the actual data conversion.</p> <p>Note that <code>yamlfile.py</code> relies on the PyYAML library to parse the YAML file. If you don't have PyYAML installed, you will need to install it using a package manager like <code>pip</code> before you can use <code>yamlfile.py</code>.</p> <p>To handle errors when reading the YAML config file, <code>yamlfile.py</code> raises a <code>YamlFileError</code> exception. This exception is raised if the YAML file is not found, if the YAML file is malformed, or if a required field is missing from the conversion rule. You can catch this exception and handle it appropriately in your code.</p> <p>Here's an example of how to catch the <code>YamlFileError</code> exception:</p> <pre><code>import yamlfile\n\nconfig_file = 'my_config.yaml'\n\ntry:\n    conversion_rules = yamlfile.read_yaml_file(config_file)\nexcept yamlfile.YamlFileError as e:\n    print(f\"Error reading YAML file: {str(e)}\")\n</code></pre> <p>This will catch any YamlFileError exceptions raised by <code>read_yaml_file()</code> and print an error message.</p> <p>In summary, <code>yamlfile.py</code> is a module that reads in a YAML config file containing conversion rules and creates a Python object representing the rules. This object can be used by other code in the data conversion process. To use <code>yamlfile.py</code>, you need to create a YAML config file containing conversion rules, and then use the <code>read_yaml_file()</code> function to read the file into a Python object. You can then use the object to get the conversion rule for a specific source and target format, and perform the actual data conversion.</p>"},{"location":"api/CSVDump/","title":"CSVDump.py","text":"<p>             Bases: <code>Convert</code></p> <p>A class to parse the CSV files from ODK Central</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.parseXLS","title":"parseXLS","text":"<pre><code>parseXLS(xlsfile)\n</code></pre> <p>Parse the source XLSFile if available to look for details we need</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.createOSM","title":"createOSM","text":"<pre><code>createOSM(filespec)\n</code></pre> <p>Create an OSM XML output files</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.writeOSM","title":"writeOSM","text":"<pre><code>writeOSM(feature)\n</code></pre> <p>Write a feature to an OSM XML output file</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.finishOSM","title":"finishOSM","text":"<pre><code>finishOSM()\n</code></pre> <p>Write the OSM XML file footer and close it</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.createGeoJson","title":"createGeoJson","text":"<pre><code>createGeoJson(file='tmp.geojson')\n</code></pre> <p>Create a GeoJson output file</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.writeGeoJson","title":"writeGeoJson","text":"<pre><code>writeGeoJson(feature)\n</code></pre> <p>Write a feature to a GeoJson output file</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.finishGeoJson","title":"finishGeoJson","text":"<pre><code>finishGeoJson()\n</code></pre> <p>Write the GeoJson FeatureCollection to the output file and close it</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.parse","title":"parse","text":"<pre><code>parse(filespec, data=None)\n</code></pre> <p>Parse the CSV file from ODK Central and convert it to a data structure</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.basename","title":"basename","text":"<pre><code>basename(line)\n</code></pre> <p>Extract the basename of a path after the last -</p>"},{"location":"api/CSVDump/#osm_fieldwork.CSVDump.CSVDump.createEntry","title":"createEntry","text":"<pre><code>createEntry(entry)\n</code></pre> <p>Create the feature data structure</p>"},{"location":"api/ODKForm/","title":"OdkForm","text":""},{"location":"api/ODKForm/#osm_fieldwork.ODKForm.ODKForm","title":"ODKForm","text":"<pre><code>ODKForm()\n</code></pre> <p>             Bases: <code>object</code></p> <p>Support for parsing an XLS Form, currently a work in progress...</p> Source code in <code>osm_fieldwork/ODKForm.py</code> <pre><code>def __init__(self):\n\"\"\"\n    Returns:\n        (ODKForm): An instance of this object\n    \"\"\"\n    self.fields = dict()\n    self.nodesets = dict()\n    self.groups = dict()\n    self.ignore = (\"label\", \"@appearance\", \"hint\", \"upload\")\n</code></pre>"},{"location":"api/ODKForm/#osm_fieldwork.ODKForm.ODKForm.parseSelect","title":"parseSelect","text":"<pre><code>parseSelect(select)\n</code></pre> <p>Parse a select statement in XML</p> <p>Parameters:</p> Name Type Description Default <code>select</code> <code>dict</code> <p>The select in XML:</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data from the select</p> Source code in <code>osm_fieldwork/ODKForm.py</code> <pre><code>def parseSelect(self,\n                select: dict,\n                ):\n\"\"\"\n    Parse a select statement in XML\n\n    Args:\n        select (dict): The select in XML:\n\n    Returns:\n        (dict): The data from the select\n    \"\"\"\n    print(\"parseSelect %r\" % type(select))\n    newsel = dict()\n    if \"item\" in select:\n        data = self.parseItems(select[\"item\"])\n        ref = os.path.basename(select[\"@ref\"])\n        for key in data:\n            if key in self.ignore:\n                continue\n            newsel[ref] = data\n        print(\"\\tQQQQQ %r\" % (newsel))\n    return newsel\n</code></pre>"},{"location":"api/ODKForm/#osm_fieldwork.ODKForm.ODKForm.parseItems","title":"parseItems","text":"<pre><code>parseItems(items)\n</code></pre> <p>Parse the items in a select list</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list</code> <p>The select items list in XML:</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data from the list of items</p> Source code in <code>osm_fieldwork/ODKForm.py</code> <pre><code>def parseItems(self,\n               items: list,\n               ):\n\"\"\"\n    Parse the items in a select list\n\n    Args:\n        items (list): The select items list in XML:\n\n    Returns:\n        (dict): The data from the list of items\n    \"\"\"\n    print(\"\\tparseItems: %r: %r\" % (type(items), items))\n    newitems = list()\n    # if type(items) == OrderedDict:\n    #     data = list()\n    #     data.append(items)\n    # else:\n    #     data = items\n\n    for values in items:\n        newitems.append(values[\"value\"])\n\n        # if type(values) == str:\n        #     continue\n\n    #     val = values['label']['@ref'].replace(\"/data/\", \"\")\n    #     tmp = val.split('/')\n    #     group = tmp[0].replace(\"jr:itext(\\'\", \"\")\n    #     fields = len(tmp)\n    #     if fields &gt; 2:\n    #         subgroup = tmp[1]\n    #         label = tmp[2].replace(\":label\\')\", \"\")\n    #     else:\n    #         subgroup = None\n    #         label = tmp[1].replace(\":label\\')\", \"\")\n    #     # print(\"VALUES: %r / %r / %r\" % (group, subgroup, label))\n    #     if subgroup not in newdata:\n    #         newdata[subgroup] = list()\n    #     #newdata[subgroup].append(label)\n    #     newitems.append(label)\n    # return group, subgroup, newitems\n    return newitems\n</code></pre>"},{"location":"api/ODKForm/#osm_fieldwork.ODKForm.ODKForm.parseGroup","title":"parseGroup","text":"<pre><code>parseGroup(group)\n</code></pre> <p>Convert the XML of a group into a data structure.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>dict</code> <p>The group data</p> required Source code in <code>osm_fieldwork/ODKForm.py</code> <pre><code>def parseGroup(self,\n               group: dict(),\n               ):\n\"\"\"\n    Convert the XML of a group into a data structure.\n\n    Args:\n        group (dict): The group data\n    \"\"\"\n    print(\"\\tparseGroup %r\" % (type(group)))\n    if type(group) == list:\n        for val in group:\n            for k in group:\n                print(\"\\nZZZZ1 %r\" % (k))\n    else:  # it's a list\n        for keyword, data in group.items():\n            # FIXME: for now,. ignore media files\n            if keyword in self.ignore:\n                continue\n            print(\"WWW3 %r, %r\" % (keyword, type(data)))\n            # pat = re.compile('select[0-9]*')\n            # if pat.match(keyword):\n            if keyword[0:6] == \"select\":\n                print(\"WWW4 select\")\n                self.parseSelect(data)\n</code></pre>"},{"location":"api/ODKInstance/","title":"OdkForm","text":""},{"location":"api/ODKInstance/#osm_fieldwork.ODKInstance.ODKInstance","title":"ODKInstance","text":"<pre><code>ODKInstance(filespec=None, data=None)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The filespec to the ODK XML Instance file</p> <code>None</code> <code>data</code> <code>str</code> <p>The XML data</p> <code>None</code> <p>Returns:</p> Type Description <code>ODKInstance</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/ODKInstance.py</code> <pre><code>def __init__(self,\n             filespec: str = None,\n             data: str = None,\n             ):\n\"\"\"\n    This class imports a ODK Instance file, which is in XML into a data\n    structure.\n\n    Args:\n        filespec (str): The filespec to the ODK XML Instance file\n        data (str): The XML data\n\n    Returns:\n        (ODKInstance): An instance of this object\n    \"\"\"\n    self.data = data\n    self.filespec = filespec\n    if filespec:\n        self.data = self.parse(filespec=filespec)\n    elif data:\n        self.data = self.parse(data)\n</code></pre>"},{"location":"api/ODKInstance/#osm_fieldwork.ODKInstance.ODKInstance.parse","title":"parse","text":"<pre><code>parse(filespec, data=None)\n</code></pre> <p>Import an ODK XML Instance file ito a data structure. The input is either a filespec to the Instance file copied off your phone, or the XML that has been read in elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The filespec to the ODK XML Instance file</p> required <code>data</code> <code>str</code> <p>The XML data</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>All the entries in the IOPDK XML Instance file</p> Source code in <code>osm_fieldwork/ODKInstance.py</code> <pre><code>def parse(self,\n          filespec: str,\n          data: str = None,\n          ):\n\"\"\"\n    Import an ODK XML Instance file ito a data structure. The input is\n    either a filespec to the Instance file copied off your phone, or\n    the XML that has been read in elsewhere.\n\n    Args:\n        filespec (str): The filespec to the ODK XML Instance file\n        data (str): The XML data\n\n    Returns:\n        (list): All the entries in the IOPDK XML Instance file\n    \"\"\"\n    rows = list()\n    if filespec:\n        logging.info(\"Processing instance file: %s\" % filespec)\n        file = open(filespec, \"rb\")\n        # Instances are small, read the whole file\n        xml = file.read(os.path.getsize(filespec))\n    elif data:\n        xml = data\n    doc = xmltodict.parse(xml)\n    import json\n    json.dumps(doc)\n    tags = dict()\n    data = doc[\"data\"]\n    for i, j in data.items():\n        if j is None or i == 'meta':\n            continue\n        print(f\"tag: {i} == {j}\")\n        pat = re.compile(\"[0-9.]* [0-9.-]* [0-9.]* [0-9.]*\")\n        if pat.match(str(j)):\n            if i == 'warmup':\n                continue\n            gps = j.split(\" \")\n            tags[\"lat\"] = gps[0]\n            tags[\"lon\"] = gps[1]\n            continue\n        if type(j) == OrderedDict or type(j) == dict:\n            for ii, jj in j.items():\n                pat = re.compile(\"[0-9.]* [0-9.-]* [0-9.]* [0-9.]*\")\n                if pat.match(str(jj)):\n                    gps = jj.split(\" \")\n                    tags[\"lat\"] = gps[0]\n                    tags[\"lon\"] = gps[1]\n                    continue\n                if jj is None:\n                    continue\n                print(f\"tag: {i} == {j}\")\n                if type(jj) == OrderedDict or type(jj) == dict:\n                    for iii, jjj in jj.items():\n                        if jjj is not None:\n                            tags[iii] = jjj\n                            # print(iii, jjj)\n                        else:\n                            print(ii, jj)\n                            tags[ii] = jj\n                else:\n                    if i[0:1] != \"@\":\n                        tags[i] = j\n        rows.append(tags)\n    return rows\n</code></pre>"},{"location":"api/OdkCentral/","title":"OdkCentral","text":"<p>Download a list of submissions from ODK Central</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xforms</code> <code>list</code> <p>A list of the XForms to down the submissions from</p> required <code>odk_credentials</code> <code>dict</code> <p>The authentication credentials for ODK Collect</p> required <p>Returns:</p> Type Description <code>list</code> <p>The submissions in JSON format</p> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>OdkCentral</code> <p>An instance of this class</p> <p>             Bases: <code>OdkCentral</code></p> <p>Class to manipulate a project on an ODK Central server</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central\n</code></pre> <p>Returns:</p> Type Description <code>OdkProject</code> <p>An instance of this object</p> <p>             Bases: <code>OdkCentral</code></p> <p>Class to manipulate a from on an ODK Central server</p> <pre><code>user (str): The user's account name on ODK Central\npasswd (str):  The user's account password on ODK Central\n</code></pre> <p>Returns:</p> Type Description <code>OdkForm</code> <p>An instance of this object</p> <p>             Bases: <code>OdkCentral</code></p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>OdkAppUser</code> <p>An instance of this object</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.authenticate","title":"authenticate","text":"<pre><code>authenticate(url=None, user=None, passwd=None)\n</code></pre> <p>Setup authenticate to an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the ODK Central</p> <code>None</code> <code>user</code> <code>str</code> <p>The user's account name on ODK Central</p> <code>None</code> <code>passwd</code> <code>str</code> <p>The user's account password on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>HTTPBasicAuth</code> <p>A session to the ODK Central server</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.listProjects","title":"listProjects","text":"<pre><code>listProjects()\n</code></pre> <p>Fetch a list of projects from an ODK Central server, and store it as an indexed list.</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of projects on a ODK Central server</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.createProject","title":"createProject","text":"<pre><code>createProject(name)\n</code></pre> <p>Create a new project on an ODK Central server if it doesn't already exist</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name for the new project</p> required <p>Returns:</p> Type Description <code>json</code> <p>The response from ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.deleteProject","title":"deleteProject","text":"<pre><code>deleteProject(project_id)\n</code></pre> <p>Delete a project on an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>str</code> <p>The project name</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.findProject","title":"findProject","text":"<pre><code>findProject(name=None, project_id=None)\n</code></pre> <p>Get the project data from Central</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>the project data from ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.findAppUser","title":"findAppUser","text":"<pre><code>findAppUser(user_id, name=None)\n</code></pre> <p>Get the data for an app user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID of the app-user on ODK Central</p> required <code>name</code> <code>str</code> <p>The name of the app-user on ODK Central</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The data for an app-user on ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.listUsers","title":"listUsers","text":"<pre><code>listUsers()\n</code></pre> <p>Fetch a list of users on the ODK Central server</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of users on ODK Central, not app-users</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkCentral.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getData","title":"getData","text":"<pre><code>getData(keyword)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for the keyword</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.listForms","title":"listForms","text":"<pre><code>listForms(project_id, metadata=False)\n</code></pre> <p>Fetch a list of forms in a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of XForms in this project</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getAllSubmissions","title":"getAllSubmissions","text":"<pre><code>getAllSubmissions(project_id, xforms=None, filters=None)\n</code></pre> <p>Fetch a list of submissions in a project on an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xforms</code> <code>list</code> <p>The list of XForms to get the submissions of</p> <code>None</code> <p>Returns:</p> Type Description <code>json</code> <p>All of the submissions for all of the XForm in a project</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.listAppUsers","title":"listAppUsers","text":"<pre><code>listAppUsers(projectId)\n</code></pre> <p>Fetch a list of app users for a project from an ODK Central server.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of app-users on ODK Central for this project</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.listAssignments","title":"listAssignments","text":"<pre><code>listAssignments(projectId)\n</code></pre> <p>List the Role &amp; Actor assignments for users on a project</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The list of assignments</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getDetails","title":"getDetails","text":"<pre><code>getDetails(projectId)\n</code></pre> <p>Get all the details for a project on an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>Get the data about a project on ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.getFullDetails","title":"getFullDetails","text":"<pre><code>getFullDetails(projectId)\n</code></pre> <p>Get extended details for a project on an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>Get the data about a project on ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkProject.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getDetails","title":"getDetails","text":"<pre><code>getDetails(projectId, xform)\n</code></pre> <p>Get all the details for a form on an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getFullDetails","title":"getFullDetails","text":"<pre><code>getFullDetails(projectId, xform)\n</code></pre> <p>Get the full details for a form on an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listSubmissionBasicInfo","title":"listSubmissionBasicInfo","text":"<pre><code>listSubmissionBasicInfo(projectId, xform)\n</code></pre> <p>Fetch a list of submission instances basic information for a given form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listSubmissions","title":"listSubmissions","text":"<pre><code>listSubmissions(projectId, xform, filters=None)\n</code></pre> <p>Fetch a list of submission instances for a given form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of Submissions</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listAssignments","title":"listAssignments","text":"<pre><code>listAssignments(projectId, xform)\n</code></pre> <p>List the Role &amp; Actor assignments for users on a project</p> <p>Fetch a list of submission instances basic information for a given form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>json</code> <p>The data for this XForm</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getSubmissions","title":"getSubmissions","text":"<pre><code>getSubmissions(projectId, xform, submission_id, disk=False, json=True)\n</code></pre> <p>Fetch a CSV or JSON file of the submissions without media to a survey form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>submission_id</code> <code>int</code> <p>The ID of the submissions to download</p> required <code>disk</code> <code>bool</code> <p>Whether to write the downloaded file to disk</p> <code>False</code> <code>json</code> <code>bool</code> <p>Download JSON or CSV format</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>The lit of submissions</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getSubmissionMedia","title":"getSubmissionMedia","text":"<pre><code>getSubmissionMedia(projectId, xform)\n</code></pre> <p>Fetch a ZIP file of the submissions with media to a survey form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>The media file</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.addMedia","title":"addMedia","text":"<pre><code>addMedia(media, filespec)\n</code></pre> <p>Add a data file to this form</p> <p>Parameters:</p> Name Type Description Default <code>media</code> <code>str</code> <p>The media file</p> required <code>filespec</code> <code>str</code> <p>the name of the media</p> required"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.addXMLForm","title":"addXMLForm","text":"<pre><code>addXMLForm(projectId, xmlFormId, xform)\n</code></pre> <p>Add an XML file to this form</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.listMedia","title":"listMedia","text":"<pre><code>listMedia(projectId, xform)\n</code></pre> <p>List all the attchements for this form</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of al the media files for this project</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.uploadMedia","title":"uploadMedia","text":"<pre><code>uploadMedia(projectId, xform, filespec, convert_to_draft=True)\n</code></pre> <p>Upload an attachement to the ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>filespec</code> <code>str</code> <p>The filespec of the media file</p> required <code>convert_to_draft</code> <code>bool</code> <p>Whether to convert a published XForm to draft</p> <code>True</code>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.getMedia","title":"getMedia","text":"<pre><code>getMedia(projectId, xform, filename)\n</code></pre> <p>Fetch a specific attachment by filename from a submission to a form.</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>filename</code> <code>str</code> <p>The name of the attachment for the XForm on ODK Central</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The media data</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.createForm","title":"createForm","text":"<pre><code>createForm(projectId, xform, filespec, draft=False)\n</code></pre> <p>Create a new form on an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>filespec</code> <code>str</code> <p>The name of the attachment for the XForm on ODK Central</p> required <code>draft</code> <code>bool</code> <p>Whether to create the XForm in draft or published</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>The status code from ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.deleteForm","title":"deleteForm","text":"<pre><code>deleteForm(projectId, xform)\n</code></pre> <p>Delete a form from an ODK Central server</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:     (bool): did it get deleted</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.publishForm","title":"publishForm","text":"<pre><code>publishForm(projectId, xform)\n</code></pre> <p>Publish a draft form. When creating a form that isn't a draft, it can get publised then</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <p>Returns:</p> Type Description <code>int</code> <p>The staus code from ODK Central</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkForm.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.create","title":"create","text":"<pre><code>create(projectId, name)\n</code></pre> <p>Create a new app-user for a form</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>name</code> <code>str</code> <p>The name of the XForm</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether it was created or not</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.delete","title":"delete","text":"<pre><code>delete(projectId, userId)\n</code></pre> <p>Create a new app-user for a form</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>userId</code> <code>int</code> <p>The ID of the user on ODK Central to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user got deleted or not</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.updateRole","title":"updateRole","text":"<pre><code>updateRole(projectId, xform, roleId=2, actorId=None)\n</code></pre> <p>Update the role of an app user for a form</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> required <code>roleId</code> <code>int</code> <p>The role for the user</p> <code>2</code> <code>actorId</code> <code>int</code> <p>The ID of the user</p> <code>None</code> <p>Returns     (bool): Whether it was update or not</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.grantAccess","title":"grantAccess","text":"<pre><code>grantAccess(projectId, roleId=2, userId=None, xform=None, actorId=None)\n</code></pre> <p>Grant access to an app user for a form</p> <p>Parameters:</p> Name Type Description Default <code>projectId</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>roleId</code> <code>int</code> <p>The role ID</p> <code>2</code> <code>userId</code> <code>int</code> <p>The user ID of the user on ODK Central</p> <code>None</code> <code>xform</code> <code>str</code> <p>The XForm to get the details of from ODK Central</p> <code>None</code> <code>actorId</code> <code>int</code> <p>The actor ID of the user on ODK Central</p> <code>None</code> <p>Returns     (bool): Whether access was granted or not</p>"},{"location":"api/OdkCentral/#osm_fieldwork.OdkCentral.OdkAppUser.createQRCode","title":"createQRCode","text":"<pre><code>createQRCode(project_id, token, name)\n</code></pre> <p>Get the QR Code for an app-user</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project on ODK Central</p> required <code>token</code> <code>str</code> <p>The user's token</p> required <code>name</code> <code>str</code> <p>The name of the project</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The new QR code</p>"},{"location":"api/basemapper/","title":"basemapper.py","text":"<p>Thread to handle downloads for Queue</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>str</code> <p>The filespec of the tile cache</p> required <code>mirrors</code> <code>list</code> <p>The list of mirrors to get imagery</p> required <code>tiles</code> <code>list</code> <p>The list of tiles to download</p> required <code>xy</code> <code>bool</code> <p>Whether to swap the X &amp; Y fields in the TMS URL</p> required <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>str</code> <p>A BBOX string or GeoJSON file of the AOI. The GeoJSON can contain multiple geometries.</p> required <code>base</code> <code>str</code> <p>The base directory to cache map tile in</p> required <code>source</code> <code>str</code> <p>The upstream data source for map tiles</p> required <code>xy</code> <code>bool</code> <p>Whether to swap the X &amp; Y fields in the TMS URL</p> required <p>Returns:</p> Type Description <code>BaseMapper</code> <p>An instance of this class</p>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.customTMS","title":"customTMS","text":"<pre><code>customTMS(url, name='custom', source='custom', suffix='jpg')\n</code></pre> <p>Add a custom TMS URL to the list of sources.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to display</p> <code>'custom'</code> <code>url</code> <code>str</code> <p>The URL string</p> required <code>suffix</code> <code>str</code> <p>The suffix, png or jpg</p> <code>'jpg'</code> <code>source</code> <code>str</code> <p>The source value to use as an index</p> <code>'custom'</code>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.getFormat","title":"getFormat","text":"<pre><code>getFormat()\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>the upstream source for map tiles</p>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.getTiles","title":"getTiles","text":"<pre><code>getTiles(zoom=None)\n</code></pre> <p>Get a list of tiles for the specifed zoom level</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>int</code> <p>The Zoom level of the desired map tiles</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The total number of map tiles downloaded</p>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.tileExists","title":"tileExists","text":"<pre><code>tileExists(tile)\n</code></pre> <p>See if a map tile already exists</p> <p>Parameters:</p> Name Type Description Default <code>tile</code> <code>MapTile</code> <p>The map tile to check for the existence of</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the tile exists in the map tile cache</p>"},{"location":"api/basemapper/#osm_fieldwork.basemapper.BaseMapper.makeBbox","title":"makeBbox","text":"<pre><code>makeBbox(boundary)\n</code></pre> <p>Make a bounding box from a shapely geometry.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>str</code> <p>A BBOX string or GeoJSON file of the AOI. The GeoJSON can contain multiple geometries.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The bounding box coordinates</p>"},{"location":"api/convert/","title":"convert.py","text":"<p>             Bases: <code>YamlFile</code></p> <p>A class to apply a YAML config file and convert ODK to OSM</p> <p>Returns:</p> Type Description <code>Convert</code> <p>An instance of this object</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.privateData","title":"privateData","text":"<pre><code>privateData(keyword)\n</code></pre> <p>See is a keyword is in the private data category</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the private data section</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertData","title":"convertData","text":"<pre><code>convertData(keyword)\n</code></pre> <p>See is a keyword is in the convert data category</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the convert data section</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.ignoreData","title":"ignoreData","text":"<pre><code>ignoreData(keyword)\n</code></pre> <p>See is a keyword is in the convert data category</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the ignore data section</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.getKeyword","title":"getKeyword","text":"<pre><code>getKeyword(value)\n</code></pre> <p>Get the keyword for a value from the yaml file</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The value to find the keyword for</p> required <p>Returns:     (str): The keyword if found, or None</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.getValues","title":"getValues","text":"<pre><code>getValues(keyword=None)\n</code></pre> <p>Get the values for a primary key</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to get the value of</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The values or None</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertEntry","title":"convertEntry","text":"<pre><code>convertEntry(tag, value)\n</code></pre> <p>Convert a tag and value from the ODK represention to an OSM one</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag from the ODK XML file</p> required <code>value</code> <code>str</code> <p>The value from the ODK XML file</p> required <p>Returns:</p> Type Description <code>list</code> <p>The converted values</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertValue","title":"convertValue","text":"<pre><code>convertValue(tag, value)\n</code></pre> <p>Convert a single tag value</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag from the ODK XML file</p> required <code>value</code> <code>str</code> <p>The value from the ODK XML file</p> required <p>Returns:</p> Type Description <code>list</code> <p>The converted values</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.convertTag","title":"convertTag","text":"<pre><code>convertTag(tag)\n</code></pre> <p>Convert a single tag</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>The tag from the ODK XML file</p> required <p>Returns:</p> Type Description <code>str</code> <p>The new tag</p>"},{"location":"api/convert/#osm_fieldwork.convert.Convert.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/filter_data/","title":"filter_data.py","text":"<p>             Bases: <code>object</code></p> <p>Returns:</p> Type Description <code>FilterData</code> <p>An instance of this object</p>"},{"location":"api/filter_data/#osm_fieldwork.filter_data.FilterData.parse","title":"parse","text":"<pre><code>parse(filespec, config)\n</code></pre> <p>Read in the XLSForm and extract the data we want</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The filespec to the XLSForm file</p> required <p>Returns:</p> Name Type Description <code>title</code> <code>str</code> <p>The title from the XLSForm Setting sheet</p> <code>extract</code> <code>str</code> <p>The data extract filename from the XLSForm Survey sheet</p>"},{"location":"api/filter_data/#osm_fieldwork.filter_data.FilterData.cleanData","title":"cleanData","text":"<pre><code>cleanData(data)\n</code></pre> <p>Filter out any data not in the data_model</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The input data or filespec to the input data file</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>The modifed data</p>"},{"location":"api/json2osm/","title":"json2osm.py","text":"<p>             Bases: <code>Convert</code></p> <p>A class to parse the JSON files from ODK Central or odk2geojson</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <code>str</code> <p>The filespec of the YAML config file</p> <code>None</code> <p>Returns:</p> Type Description <code>JsonDump</code> <p>An instance of this object</p>"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.createOSM","title":"createOSM","text":"<pre><code>createOSM(filespec='tmp.osm')\n</code></pre> <p>Create an OSM XML output files</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The filespec for the output OSM XML file</p> <code>'tmp.osm'</code> <p>Returns:</p> Type Description <code>OsmFile</code> <p>An instance of the OSM XML output file</p>"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.writeOSM","title":"writeOSM","text":"<pre><code>writeOSM(feature)\n</code></pre> <p>Write a feature to an OSM XML output file</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>dict</code> <p>The feature to write to the OSM XML output file</p> required"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.finishOSM","title":"finishOSM","text":"<pre><code>finishOSM()\n</code></pre> <p>Write the OSM XML file footer and close it. The destructor in the OsmFile class should do this, but this is the manual way.</p>"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.createGeoJson","title":"createGeoJson","text":"<pre><code>createGeoJson(file='tmp.geojson')\n</code></pre> <p>Create a GeoJson output file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>The filespec of the output GeoJson file</p> <code>'tmp.geojson'</code>"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.writeGeoJson","title":"writeGeoJson","text":"<pre><code>writeGeoJson(feature)\n</code></pre> <p>Write a feature to a GeoJson output file</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>dict</code> <p>The feature to write to the GeoJson output file</p> required"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.finishGeoJson","title":"finishGeoJson","text":"<pre><code>finishGeoJson()\n</code></pre> <p>Write the GeoJson FeatureCollection to the output file and close it.</p>"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.parse","title":"parse","text":"<pre><code>parse(filespec=None, data=None)\n</code></pre> <p>Parse the JSON file from ODK Central and convert it to a data structure. The input is either a filespec to open, or the data itself.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The JSON or GeoJson input file to convert</p> <code>None</code> <code>data</code> <code>str</code> <p>The data to convert</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of all the features in the input file</p>"},{"location":"api/json2osm/#osm_fieldwork.json2osm.JsonDump.createEntry","title":"createEntry","text":"<pre><code>createEntry(entry)\n</code></pre> <p>Create the feature data structure for this entry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>dict</code> <p>The feature to convert to the output format</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The new entry for the output file</p>"},{"location":"api/make_data_extract/","title":"make_data_extract.py","text":"<p>Get the categories and associated XLSFiles from the config file</p> <p>Returns:</p> Type Description <code>list</code> <p>A list of the XLSForms included in osm-fieldwork</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def getChoices():\n\"\"\"\n    Get the categories and associated XLSFiles from the config file\n\n    Returns:\n        (list): A list of the XLSForms included in osm-fieldwork\n    \"\"\"\n    data = dict()\n    if os.path.exists(f\"{rootdir}/data_models/category.yaml\"):\n        file = open(f\"{rootdir}/data_models/category.yaml\", \"r\").read()\n        contents = yaml.load(file, Loader=yaml.Loader)\n        for entry in contents:\n            [[k,v]] = entry.items()\n            data[k] = v[0]\n    return data\n</code></pre> <p>options: show_source: false heading_level: 3</p> <p>             Bases: <code>object</code></p> <p>Class to handle SQL queries for the categories</p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> required <code>config</code> <code>str</code> <p>The filespec for the query config file</p> required <code>xlsfile</code> <code>str</code> <p>The filespec for the XLSForm file</p> required <p>Returns:</p> Type Description <code>MakeExtract</code> <p>An instance of this object</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def __init__(self,\n             uri: str,\n             config: str,\n             xlsfile: str,\n):\n\"\"\"\n    Initialize the postgres handler\n\n    Args:\n        dburi (str): The URI string for the database connection\n        config (str): The filespec for the query config file\n        xlsfile (str): The filespec for the XLSForm file\n\n    Returns:\n        (MakeExtract): An instance of this object\n    \"\"\"\n    self.db = PostgresClient(uri, f\"{rootdir}/data_models/{config}\")\n    # path = Path(config)\n    # if path.suffix == '.yaml':\n    #     self.qc.parseYaml(f\"{rootdir}/data_models/{config}\")\n    # else:\n    #     self.qc.parseJson(f\"{rootdir}/data_models/{config}\")\n\n    # Read in the XLSFile\n    if '/' in xlsfile:\n        file = open(xlsfile, 'rb')\n    else:\n        file = open(f\"{rootdir}/{xlsfile}\", 'rb')\n    self.xls = BytesIO(file.read())\n</code></pre> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/make_data_extract/#osm_fieldwork.make_data_extract.MakeExtract.getFeatures","title":"getFeatures","text":"<pre><code>getFeatures(boundary, polygon)\n</code></pre> <p>Extract features from Postgres</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>str</code> <p>The filespec for the project AOI in GeoJson format</p> required <code>filespec</code> <code>str</code> <p>The optional output file for the query</p> required <code>polygon</code> <code>bool</code> <p>Whether to have the full geometry or just centroids returns</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>The features returned from the query</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def getFeatures(self,\n                boundary: FeatureCollection,\n                polygon: bool,\n                ):\n\"\"\"\n    Extract features from Postgres\n\n    Args:\n        boundary (str): The filespec for the project AOI in GeoJson format\n        filespec (str): The optional output file for the query\n        polygon (bool): Whether to have the full geometry or just centroids returns\n\n    Returns:\n        (FeatureCollection): The features returned from the query\n    \"\"\"\n    log.info(\"Extracting features from Postgres...\")\n\n    if 'features' in boundary:\n        poly = boundary['features'][0]['geometry']\n    else:\n        poly = boundary[\"geometry\"]\n    wkt = shape(poly)\n\n    collection = self.db.execQuery(boundary)\n    if not collection:\n        return None\n\n    return collection\n</code></pre>"},{"location":"api/make_data_extract/#osm_fieldwork.make_data_extract.MakeExtract.cleanFeatures","title":"cleanFeatures","text":"<pre><code>cleanFeatures(collection)\n</code></pre> <p>Filter out any data not in the data_model</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>bytes</code> <p>The input data or filespec to the input data file</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>The modifed data</p> Source code in <code>osm_fieldwork/make_data_extract.py</code> <pre><code>def cleanFeatures(self,\n                  collection: FeatureCollection,\n                  ):\n\"\"\"\n    Filter out any data not in the data_model\n\n    Args:\n        collection (bytes): The input data or filespec to the input data file\n\n    Returns:\n        (FeatureCollection): The modifed data\n\n    \"\"\"\n    log.debug(\"Cleaning features\")\n    cleaned = FilterData()\n    cleaned.parse(self.xls, self.db.qc.config)\n    new = cleaned.cleanData(collection)\n    #jsonfile = open(filespec, \"w\")\n    #dump(new, jsonfile)\n    return new\n</code></pre>"},{"location":"api/odk2csv/","title":"odk2csv.py","text":""},{"location":"api/odk2csv/#osm_fieldwork.odk2csv.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This is a program that reads in the ODK Instance file, which is in XML, and converts it to a CSV file so it can be viewed in an spreadsheet program. The CSV syntax is the same as what can be downloaded from ODK Central.</p>"},{"location":"api/odk2geojson/","title":"odk2geojson.py","text":""},{"location":"api/odk2geojson/#osm_fieldwork.odk2geojson.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This is a program that reads in the ODK Instance file, which is in XML, and converts it to a GeoJson file so it can be viewed in an editor.</p>"},{"location":"api/odk2osm/","title":"odk2osm.py","text":""},{"location":"api/odk2osm/#osm_fieldwork.odk2osm.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This is a program that reads in the ODK Instance file, which is in XML, and converts it to an OSM XML file so it can be viewed in an editor.</p>"},{"location":"api/osmfile/","title":"osmfile.py","text":"<p>             Bases: <code>object</code></p> <p>OSM File output</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The input or output file</p> <code>None</code> <code>options</code> <code>dict</code> <p>Command line options</p> <code>dict()</code> <code>outdir</code> <code>str</code> <p>The output directory for the file</p> <code>'/tmp/'</code> <p>Returns:</p> Type Description <code>OsmFile</code> <p>An instance of this object</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.isclosed","title":"isclosed","text":"<pre><code>isclosed()\n</code></pre> <p>Is the OSM XML file open or closed ?</p> <p>Returns:</p> Type Description <code>bool</code> <p>The OSM XML file status</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.header","title":"header","text":"<pre><code>header()\n</code></pre> <p>Write the header of the OSM XML file</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.footer","title":"footer","text":"<pre><code>footer()\n</code></pre> <p>Write the footer of the OSM XML file</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.write","title":"write","text":"<pre><code>write(data=None)\n</code></pre> <p>Write the data to the OSM XML file</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.createWay","title":"createWay","text":"<pre><code>createWay(way, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node</p> <p>Parameters:</p> Name Type Description Default <code>way</code> <code>dict</code> <p>The input way data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.featureToNode","title":"featureToNode","text":"<pre><code>featureToNode(feature)\n</code></pre> <p>Convert a GeoJson feature into the data structures used here</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>dict</code> <p>The GeoJson feature to convert</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data structure used by this file</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.createNode","title":"createNode","text":"<pre><code>createNode(node, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>dict</code> <p>The input node data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.createTag","title":"createTag","text":"<pre><code>createTag(field, value)\n</code></pre> <p>Create a data structure for an OSM feature tag</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The tag name</p> required <code>value</code> <code>str</code> <p>The value for the tag</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The newly created tag pair</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.loadFile","title":"loadFile","text":"<pre><code>loadFile(osmfile)\n</code></pre> <p>Read a OSM XML file generated by osm_fieldwork</p> <p>Parameters:</p> Name Type Description Default <code>osmfile</code> <code>str</code> <p>The OSM XML file to load</p> required <p>Returns:</p> Type Description <code>list</code> <p>The entries in the OSM XML file</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.getFeature","title":"getFeature","text":"<pre><code>getFeature(id)\n</code></pre> <p>Get the data for a feature from the loaded OSM data file</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID to retrieve the feasture of</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The feature for this ID or None</p>"},{"location":"api/osmfile/#osm_fieldwork.osmfile.OsmFile.getFields","title":"getFields","text":"<pre><code>getFields()\n</code></pre> <p>Extract all the tags used in this file</p>"},{"location":"api/sqlite/","title":"osmfile.py","text":"<p>             Bases: <code>object</code></p> <p>OSM File output</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The input or output file</p> <code>None</code> <code>options</code> <code>dict</code> <p>Command line options</p> <code>dict()</code> <code>outdir</code> <code>str</code> <p>The output directory for the file</p> <code>'/tmp/'</code> <p>Returns:</p> Type Description <code>OsmFile</code> <p>An instance of this object</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.isclosed","title":"isclosed","text":"<pre><code>isclosed()\n</code></pre> <p>Is the OSM XML file open or closed ?</p> <p>Returns:</p> Type Description <code>bool</code> <p>The OSM XML file status</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.header","title":"header","text":"<pre><code>header()\n</code></pre> <p>Write the header of the OSM XML file</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.footer","title":"footer","text":"<pre><code>footer()\n</code></pre> <p>Write the footer of the OSM XML file</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.write","title":"write","text":"<pre><code>write(data=None)\n</code></pre> <p>Write the data to the OSM XML file</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.createWay","title":"createWay","text":"<pre><code>createWay(way, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node</p> <p>Parameters:</p> Name Type Description Default <code>way</code> <code>dict</code> <p>The input way data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.featureToNode","title":"featureToNode","text":"<pre><code>featureToNode(feature)\n</code></pre> <p>Convert a GeoJson feature into the data structures used here</p> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>dict</code> <p>The GeoJson feature to convert</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The data structure used by this file</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.createNode","title":"createNode","text":"<pre><code>createNode(node, modified=False)\n</code></pre> <p>This creates a string that is the OSM representation of a node</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>dict</code> <p>The input node data structure</p> required <code>modified</code> <code>bool</code> <p>Is this a modified feature ?</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The OSM XML entry</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.createTag","title":"createTag","text":"<pre><code>createTag(field, value)\n</code></pre> <p>Create a data structure for an OSM feature tag</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The tag name</p> required <code>value</code> <code>str</code> <p>The value for the tag</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The newly created tag pair</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.loadFile","title":"loadFile","text":"<pre><code>loadFile(osmfile)\n</code></pre> <p>Read a OSM XML file generated by osm_fieldwork</p> <p>Parameters:</p> Name Type Description Default <code>osmfile</code> <code>str</code> <p>The OSM XML file to load</p> required <p>Returns:</p> Type Description <code>list</code> <p>The entries in the OSM XML file</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.getFeature","title":"getFeature","text":"<pre><code>getFeature(id)\n</code></pre> <p>Get the data for a feature from the loaded OSM data file</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID to retrieve the feasture of</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The feature for this ID or None</p>"},{"location":"api/sqlite/#osm_fieldwork.osmfile.OsmFile.getFields","title":"getFields","text":"<pre><code>getFields()\n</code></pre> <p>Extract all the tags used in this file</p>"},{"location":"api/yamlfile/","title":"yamlfile.py","text":"<p>             Bases: <code>object</code></p> <p>Config file in YAML format</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The filespec of the YAML file to read</p> required <p>Returns:</p> Type Description <code>YamlFile</code> <p>An instance of this object</p>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.privateData","title":"privateData","text":"<pre><code>privateData(keyword)\n</code></pre> <p>See if a keyword is in the private data category</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the private data section</p>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.ignoreData","title":"ignoreData","text":"<pre><code>ignoreData(keyword)\n</code></pre> <p>See if a keyword is in the ignore data category</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the ignore data section</p>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.convertData","title":"convertData","text":"<pre><code>convertData(keyword)\n</code></pre> <p>See if a keyword is in the convert data category</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>The keyword to search for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Check to see if the keyword is in the convert data section</p>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.dump","title":"dump","text":"<pre><code>dump()\n</code></pre> <p>Dump internal data structures, for debugging purposes only</p>"},{"location":"api/yamlfile/#osm_fieldwork.yamlfile.YamlFile.write","title":"write","text":"<pre><code>write(table)\n</code></pre> <p>Add to the YAML file</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>list</code> <p>The name of the database table</p> required <p>Returns:</p> Type Description <code>str</code> <p>The modified YAML data</p>"}]}